/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// ----------------------------------------------------------------------------
// OPTIONS
// ----------------------------------------------------------------------------
options {
  STATIC = false;
  UNICODE_INPUT = true;
  // some performance optimizations
  ERROR_REPORTING = false;
}

// ----------------------------------------------------------------------------
// PARSER
// ----------------------------------------------------------------------------

PARSER_BEGIN(Parser)
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.atlasmap.expression.parser;

import java.io.*;
import java.util.*;

import io.atlasmap.expression.*;
import io.atlasmap.expression.internal.*;
import static io.atlasmap.expression.internal.BooleanExpression.asBooleanExpression;

/** 
 * Parser for AtlasMap expressions.
 * 
 * Do not edit this .java file directly - it is autogenerated from Parser.jj
 */
public class Parser {


    public FunctionResolver functionResolver;

}

PARSER_END(Parser)

// ----------------------------------------------------------------------------
// Tokens
// ----------------------------------------------------------------------------

/* White Space */
SPECIAL_TOKEN :
{
  " " | "\t" | "\n" | "\r" | "\f"
}

/* Comments */
SKIP:
{
  <LINE_COMMENT: "--" (~["\n","\r"])* ("\n"|"\r"|"\r\n") >
}

SKIP:
{
  <BLOCK_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

/* Reserved Words */
TOKEN [IGNORE_CASE] :
{
    <  AND     : "&&">
  | <  OR      : "||">
  | <  TRUE    : "TRUE" >
  | <  FALSE   : "FALSE" >
  | <  NULL    : "NULL" >
}

/* Literals */
TOKEN [IGNORE_CASE] :
{
    < DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* (["l","L"])? >
  | < ZERO: "0" >
  | < HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
  | < OCTAL_LITERAL: "0" (["0"-"7"])* >  
  | < FLOATING_POINT_LITERAL:  		  
          (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? // matches: 5.5 or 5. or 5.5E10 or 5.E10
        | "." (["0"-"9"])+ (<EXPONENT>)?              // matches: .5 or .5E10
        | (["0"-"9"])+ <EXPONENT>                     // matches: 5E10
    >
  | < #EXPONENT: "E" (["+","-"])? (["0"-"9"])+ >
  | < STRING_LITERAL: "'" ( ("''") | ~["'"] )*  "'" >
}

TOKEN [IGNORE_CASE] :
{
      < ID : ["a"-"z", "_"] (["a"-"z","0"-"9","_"])* >
      | < VARIABLE : "${" ( ("\\}") | ~["}"] )+ "}" >
}

// ----------------------------------------------------------------------------
// Grammar
// ----------------------------------------------------------------------------
Expression parse() :
{
    Expression left=null;
}
{

    (
        // Look for expressions in reverse precedence order.
        left = orExpression()
    )
    {
        return left;
    }
}

Expression orExpression() :
{
    Expression left;
    Expression right;
}
{
    (
        // And expressions have higher precedence than or expressions and so on..
        left = andExpression() 
        ( 
            <OR> right = andExpression() 
            {
                left = LogicExpression.createOR(asBooleanExpression(left), asBooleanExpression(right));
            }
        )*
    ) 
    {
        return left;
    }

}


Expression andExpression() :
{
    Expression left;
    Expression right;
}
{
    (
        left = equalityExpression() 
        ( 
            <AND> right = equalityExpression() 
            {
                left = LogicExpression.createAND(asBooleanExpression(left), asBooleanExpression(right));
            }
        )*
    ) 
    {
        return left;
    }
}

Expression equalityExpression() :
{
    Expression left;
    Expression right;
}
{
    (
        left = comparisonExpression() 
        ( 
            
            "==" right = comparisonExpression()
            {
                left = ComparisonExpression.createEqual(left, right);
            }
            |            
            "!=" right = comparisonExpression()
            {
                left = ComparisonExpression.createNotEqual(left, right);
            }
        )*
    ) 
    {
        return left;
    }
}

Expression comparisonExpression() :
{
    Expression left;
    Expression right;
    Expression low;
    Expression high;
    String t, u;
	boolean not;
	ArrayList list;
}
{
    (
        left = addExpression() 
        ( 
            
                ">" right = addExpression() 
                {
                    left = ComparisonExpression.createGreaterThan(left, right);
                }
            |            
                ">=" right = addExpression() 
                {
                    left = ComparisonExpression.createGreaterThanEqual(left, right);
                }
            |            
                "<" right = addExpression() 
                {
                    left = ComparisonExpression.createLessThan(left, right);
                }
            |            
                "<=" right = addExpression() 
                {
                    left = ComparisonExpression.createLessThanEqual(left, right);
                }
            |
                "==" right = addExpression()
                {
                    left = ComparisonExpression.createEqual(left, right);
                }
        )*
    ) 
    {
        return left;
    }
}

Expression addExpression() :
{
    Expression left;
    Expression right;
}
{
    left = multExpr() 
    ( 
	    LOOKAHEAD( ("+"|"-") multExpr())
	    (
	        "+" right = multExpr() 
	        {
	            left = ArithmeticExpression.createPlus(left, right);
	        }
	        |            
	        "-" right = multExpr() 
	        {
	            left = ArithmeticExpression.createMinus(left, right);
	        }
        )
        
    )*
    {
        return left;
    }
}

Expression multExpr() :
{
    Expression left;
    Expression right;
}
{
    left = unaryExpr() 
    ( 
        "*" right = unaryExpr() 
        {
	        left = ArithmeticExpression.createMultiply(left, right);
        }
        |            
        "/" right = unaryExpr() 
        {
	        left = ArithmeticExpression.createDivide(left, right);
        }
        |            
        "%" right = unaryExpr() 
        {
	        left = ArithmeticExpression.createMod(left, right);
        }
        
    )*
    {
        return left;
    }
}


Expression unaryExpr() :
{
    String s=null;
    Expression left=null;
}
{
	(
		LOOKAHEAD( "+" unaryExpr() )
	    "+" left=unaryExpr()
	    |
	    "-" left=unaryExpr()
	    {
	        left = UnaryExpression.createNegate(left);
	    }
	    |
	    "!" left=unaryExpr()
	    {
		    left = UnaryExpression.createNOT( asBooleanExpression(left) );
	    }
	    |
	    left = primaryExpr()
    )
    {
        return left;
    }

}

Expression primaryExpr() :
{
    Expression left=null;
}
{
    (
        left = literal()
        |
        left = variable()
        |
        "(" left = orExpression() ")"
        |
        left = functionExpr()
    ) 
    {
        return left;
    }
}

Expression functionExpr() :
{
    Token functionName;
    Expression left=null;
    Expression arg=null;
	ArrayList args = new ArrayList();
}
{
    (
        functionName = <ID> "("
            (
                arg = orExpression()
                {
                    args.add( arg );
                }
                (
                    ","
                    arg = orExpression()
                    {
                        args.add( arg );
                    }

                )*
            )?

        ")"
    )
    {
        return functionResolver.resolve(functionName.image, args);;
    }
}


ConstantExpression literal() :
{
    Token t;
    String s;
    ConstantExpression left=null;
}
{
    (
        (
            s = stringLiteral()
            {
                left = new ConstantExpression(s);
            }
        ) 
        | 
        (
            t = <DECIMAL_LITERAL>
            {
            	left = ConstantExpression.createFromDecimal(t.image);
            }    
        )
        |
        (
            t = <ZERO>
            {
                left = ConstantExpression.createFromDecimal(t.image);
            }
        )
        | 
        (
            t = <HEX_LITERAL>
            {
            	left = ConstantExpression.createFromHex(t.image);
            }    
        ) 
        | 
        (
            t = <OCTAL_LITERAL>
            {
            	left = ConstantExpression.createFromOctal(t.image);
            }    
        ) 
        | 
        (
            t = <FLOATING_POINT_LITERAL>
            {
            	left = ConstantExpression.createFloat(t.image);
            }    
        ) 
        | 
        (
            <TRUE>
            {
                left = ConstantExpression.TRUE;
            }    
        ) 
        | 
        (
            <FALSE>
            {
                left = ConstantExpression.FALSE;
            }    
        ) 
        | 
        (
            <NULL>
            {
                left = ConstantExpression.NULL;
            }    
        )
    )
    {
        return left;
    }
}

String stringLiteral() :
{
    Token t;
    StringBuffer rc = new StringBuffer();
    boolean first=true;
}
{
    t = <STRING_LITERAL> 
    {
    	// Decode the sting value.
    	String image = t.image;
    	for( int i=1; i < image.length()-1; i++ ) {
    		char c = image.charAt(i);
    		if( c == '\'' )
    			i++;    			
   			rc.append(c);
    	}
	    return rc.toString();
    }    
}

VariableExpression variable() :
{
    Token t;
    VariableExpression left=null;
}
{
    (
        t = <VARIABLE>
        {
            left = new VariableExpression(Strings.stripSuffix(Strings.stripPrefix(t.image, "${"), "}"));
        }
    )
    {
        return left;
    }
}
