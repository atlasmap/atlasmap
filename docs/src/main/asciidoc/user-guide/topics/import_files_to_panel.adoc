[id='import-files-to-panel']
= Import XML / JSON Schema, Instance or Java Class Files

Data mapping fundamentally involes morphing one data shape into another.  A user
defines these shapes using XML schemas, JSON notation or by establishing a simple Java
class.  Lets examine each file type independently.

* JSON Schema File: *JSONSchema.json*

```
  {
    "$schema": "http://json-schema.org/schema#",
    "description": "Order",
    "type": "object",
    "properties": {
      "order": {
        "type": "object",
        "properties": {
          "address": {
          "type": "object",
          "properties": {
            "street": { "type": "string" },
            "city": { "type": "string" },
            "state": { "type": "string" },
            "zip": { "type": "string" }
          }
        },
        "contact": {
          "type": "object",
          "properties": {
            "firstName": { "type": "string" },
            "lastName": { "type": "string" },
            "phone": { "type": "string" }
          }
        },
        "orderId": { "type": "string" }
      }
    },
    "primitives": {
      "type": "object",
      "properties": {
        "stringPrimitive": { "type": "string" },
        "booleanPrimitive": { "type": "boolean" },
        "numberPrimitive": { "type": "number" }
      }
    },
    "primitiveArrays": {
      "type": "object",
      "properties": {
        "stringArray": {
          "type": "array",
          "items": { "type": "string" }
        },
        "booleanArray": {
          "type": "array",
          "items": { "type": "boolean" }
        },
        "numberArray": {
          "type": "array",
          "items": { "type": "number" }
        }
      }
    },
    "addressList": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "street": { "type": "string" },
          "city": { "type": "string" },
          "state": { "type": "string" },
          "zip": { "type": "string" }
        }
      }
    }
    }
  }
```
Lets say we'd like to import this file into the AtlasMap *Source* panel.  Simply select the import icon
at the head of the panel.

image:ImportJSON1.png[Import a JSON File to Source Panel]

An *Open File* dialog appears.  Select the location for JSONSchema.json.

image:ImportJSON2.png[Import a JSON File to Source Panel - Open File Dialog]

The fields now appear in the *Source* panel as you've defined them in the imported JSON schema.

image:ImportJSON3.png[Import a JSON File to Source Panel - Import Complete]

Now lets import an XML schema into the *Target* panel.  

* XML Schema File: *XMLSchema.xml*

```
<d:SchemaSet xmlns:d="http://atlasmap.io/xml/schemaset/v2" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
    <xsd:schema targetNamespace="http://syndesis.io/v1/swagger-connector-template/request" elementFormDefault="qualified">
      <xsd:element name="request">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="body">
              <xsd:complexType>
                <xsd:sequence>
                  <xsd:element ref="Pet" />
                </xsd:sequence>
              </xsd:complexType>
            </xsd:element>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
    </xsd:schema>
    <d:AdditionalSchemas>
      <xsd:schema>
        <xsd:element name="Pet">
          <xsd:complexType>
            <xsd:sequence>
              <xsd:element name="id" type="xsd:decimal" />
              <xsd:element name="Category">
                <xsd:complexType>
                  <xsd:sequence>
                    <xsd:element name="id" type="xsd:decimal" />
                    <xsd:element name="name" type="xsd:string" />
                  </xsd:sequence>
                </xsd:complexType>
              </xsd:element>
              <xsd:element name="name" type="xsd:string" />
              <xsd:element name="photoUrl">
                <xsd:complexType>
                  <xsd:sequence>
                    <xsd:element name="photoUrl" type="xsd:string" maxOccurs="unbounded" minOccurs="0" />
                  </xsd:sequence>
                </xsd:complexType>
              </xsd:element>
              <xsd:element name="tag">
                <xsd:complexType>
                  <xsd:sequence>
                    <xsd:element name="Tag" maxOccurs="unbounded" minOccurs="0">
                      <xsd:complexType>
                        <xsd:sequence>
                          <xsd:element name="id" type="xsd:decimal" />
                          <xsd:element name="name" type="xsd:string" />
                        </xsd:sequence>
                      </xsd:complexType>
                    </xsd:element>
                  </xsd:sequence>
                </xsd:complexType>
              </xsd:element>
              <xsd:element name="status" type="xsd:string" />
            </xsd:sequence>
          </xsd:complexType>
        </xsd:element>
      </xsd:schema>
    </d:AdditionalSchemas>
  </d:SchemaSet>
```
As was done in the previous JSON file import, select the import icon this time in the *Target* panel.

image:ImportXML1.png[Import an XML File to Target Panel]

An *Open File* dialog appears.  Select the location for XMLSchema.xml.
The fields now appear in the *Target* panel as you've defined them in the imported XML schema.  The fields
are expanded to show more detail.

image:ImportXML2.png[Import of an XML File to Target Panel Complete]

Instance files are imported in precisely the same manner.  These files define a separate namespace
which also defines a few special attributes.  For example:

* JSON Schema Instance File: *JSONSchemaInst.json*

```
   {
        "order": {
            "address": {
                "street": "123 any st",
                "city": "Austin",
                "state": "TX",
                "zip": "78626"
            },
            "contact": {
                "firstName": "james",
                "lastName": "smith",
                "phone": "512-123-1234"
            },
            "orderId": "123"
        },
        "primitives": {
            "stringPrimitive": "some value",
            "booleanPrimitive": true,
            "numberPrimitive": 24
        },
        "addressList": [
            { "street": "123 any st", "city": "Austin", "state": "TX", "zip": "78626" },
            { "street": "123 any st", "city": "Austin", "state": "TX", "zip": "78626" },
            { "street": "123 any st", "city": "Austin", "state": "TX", "zip": "78626" },
            { "street": "123 any st", "city": "Austin", "state": "TX", "zip": "78626" }
        ]
    }
```
* XML Schema Instance File: *XMLSchemaInst.xml*

```
 <ns:XmlOE xmlns:ns="http://atlasmap.io/xml/test/v2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://atlasmap.io/xml/test/v2 atlas-xml-test-model-v2.xsd ">
    <ns:orderId>ns:orderId</ns:orderId>
    <ns:Address>
      <ns:addressLine1>ns:addressLine1</ns:addressLine1>
      <ns:addressLine2>ns:addressLine2</ns:addressLine2>
      <ns:city>ns:city</ns:city>
      <ns:state>ns:state</ns:state>
      <ns:zipCode>ns:zipCode</ns:zipCode>
    </ns:Address>
    <ns:Contact>
      <ns:firstName>ns:firstName</ns:firstName>
      <ns:lastName>ns:lastName</ns:lastName>
      <ns:phoneNumber>ns:phoneNumber</ns:phoneNumber>
      <ns:zipCode>ns:zipCode</ns:zipCode>
    </ns:Contact>
  </ns:XmlOE>
```
Using the same procedure as before, these files may be imported into either the *Source* or *Target*
panel.

There does exist one other method for establishing mappable fields within the AtlasMap data mapper.
A Java class can be established where each field is represented as a class-wide public entity.  Arrays
and data types are more discretely defined.  For example:

* Java File: *Bicycle.java*
```
package io.paul;
import io.paul.GeoLocation;

public class Bicycle {
    public int cadence;
    public int gear;
    public int speed;
    public float[] seatHeight;
    public String[] color;
    public GeoLocation geoLocation;
}
```
* Java File: *GeoLocation.java*
```
package io.paul;

public class GeoLocation {
    double lattitude;
    double longitude;
}
```
Compile the Java files and assemble the results into a Java archive file (i.e. Bicycle.jar).  Here's a hint:
```
javac -cp io.paul:. -d . GeoLocation.java Bicycle.java 
jar cvf ../Bicycle.jar *
```
Now you can import the Bicycle.jar archive into AtlasMap.  The import procedure is slightly different for
Java class archives.  You must:

Import the file into AtlasMap.  Select the import icon *on the main tool bar*, not on
the panel.

image:ImportJavaClass1.png[Import a Java Class Archive File to Source Panel]

An *Open File* dialog appears.  Select the location for Bicycle.jar.

image:ImportJavaClass2.png[Import a Java Class Archive File to Source Panel - Open Dialog]

Select the plus icon (+) on the *Source* or *Target* panel.

image:ImportJavaClass3.png[Enable a class package in a previously imported JAR]

A dialog appears "Establish your class in the Sources panel."
In the *Class package name:* input field, enter the class package name of the Java class you've defined.
In the Bicycle.jar example, the class package name is `io.paul.Bicycle`.  

image:ImportJavaClass4.png[Enable a class package in a previously imported JAR]

You will now see the fields you created in your Java class file appear in the selected panel.

image:ImportJavaClass5.png[Class Package Enablement Complete]

You have now defined the source and target data shapes.  Time to do some mapping!

