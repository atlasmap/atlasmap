<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>CsvFieldReader.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Unit Test Coverage Report</a> &gt; <a href="../index.html" class="el_bundle">atlas-csv-core</a> &gt; <a href="index.source.html" class="el_package">io.atlasmap.csv.core</a> &gt; <span class="el_source">CsvFieldReader.java</span></div><h1>CsvFieldReader.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2017 Red Hat, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.atlasmap.csv.core;

import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;

import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVRecord;

import io.atlasmap.api.AtlasException;
import io.atlasmap.core.AtlasPath;
import io.atlasmap.core.AtlasUtil;
import io.atlasmap.csv.v2.CsvComplexType;
import io.atlasmap.csv.v2.CsvField;
import io.atlasmap.csv.v2.CsvFields;
import io.atlasmap.spi.AtlasFieldReader;
import io.atlasmap.spi.AtlasInternalSession;
import io.atlasmap.v2.AtlasModelFactory;
import io.atlasmap.v2.AuditStatus;
import io.atlasmap.v2.CollectionType;
import io.atlasmap.v2.Document;
import io.atlasmap.v2.Field;
import io.atlasmap.v2.FieldGroup;
import io.atlasmap.v2.FieldType;
import io.atlasmap.v2.Fields;

/**
 * The {@link AtlasFieldReader} implementation for CSV Document.
 * It accepts InputStream as a document in order to process big files efficiently.
 * It uses the mark operation of the {@link InputStream} to reset the stream and read consecutive fields.
 * If InputStream does not support the mark operation it is wrapped in {@link BufferedInputStream}.
 */
public class CsvFieldReader implements AtlasFieldReader {

    private final CsvConfig csvConfig;
    private InputStream document;

    /**
     * A constructor.
     * @param csvConfig config
     */
<span class="fc" id="L61">    public CsvFieldReader(CsvConfig csvConfig) {</span>
<span class="fc" id="L62">        this.csvConfig = csvConfig;</span>
<span class="fc" id="L63">    }</span>

    /**
     * Sets the CSV Document.
     * @param inputStream CSV Document
     */
    public void setDocument(InputStream inputStream) {
<span class="fc bfc" id="L70" title="All 4 branches covered.">        if (inputStream != null &amp;&amp; !inputStream.markSupported()) {</span>
<span class="fc" id="L71">            this.document = new BufferedInputStream(inputStream);</span>
        } else {
<span class="fc" id="L73">            this.document = inputStream;</span>
        }
<span class="fc" id="L75">    }</span>

    @Override
    public Field read(AtlasInternalSession session) throws AtlasException {
<span class="fc" id="L79">        Field field = session.head().getSourceField();</span>

<span class="fc bfc" id="L81" title="All 2 branches covered.">        if (document == null) {</span>
<span class="fc" id="L82">            AtlasUtil.addAudit(session, field,</span>
<span class="fc" id="L83">                String.format(&quot;Cannot read field '%s' of document '%s', document is null&quot;,</span>
<span class="fc" id="L84">                    field.getPath(), field.getDocId()),</span>
                AuditStatus.ERROR, null);
<span class="fc" id="L86">            return field;</span>
        }
<span class="pc bpc" id="L88" title="1 of 2 branches missed.">        if (field == null) {</span>
<span class="nc" id="L89">            throw new AtlasException(new IllegalArgumentException(&quot;Argument 'field' cannot be null&quot;));</span>
        }
<span class="pc bpc" id="L91" title="3 of 4 branches missed.">        if (!(field instanceof CsvField) &amp;&amp; !(field instanceof FieldGroup)) {</span>
<span class="nc" id="L92">            throw new AtlasException(String.format(&quot;Unsupported field type '%s'&quot;, field.getClass()));</span>
        }

<span class="pc bpc" id="L95" title="1 of 2 branches missed.">        if (field instanceof FieldGroup) {</span>
            //complex field
<span class="nc" id="L97">            FieldGroup fieldGroup = (FieldGroup) field;</span>
<span class="nc" id="L98">            List&lt;Field&gt; fields = fieldGroup.getField();</span>

<span class="nc" id="L100">            FieldGroup readFieldGroup = AtlasModelFactory.copyFieldGroup(fieldGroup);</span>

<span class="nc bnc" id="L102" title="All 2 branches missed.">            for (Field subField: fields) {</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">                if (subField instanceof FieldGroup) {</span>
                    //support only one level grouping
<span class="nc" id="L105">                    subField = ((FieldGroup) subField).getField().get(0);</span>
                }

<span class="nc bnc" id="L108" title="All 2 branches missed.">                if (subField instanceof CsvField) {</span>
<span class="nc" id="L109">                    Field readSubField = readFields((CsvField) subField);</span>
<span class="nc" id="L110">                    readFieldGroup.getField().add(readSubField);</span>
                }
<span class="nc" id="L112">            }</span>

<span class="nc" id="L114">            session.head().setSourceField(readFieldGroup);</span>
<span class="nc" id="L115">            return readFieldGroup;</span>
        } else {
<span class="fc" id="L117">            Field readField = readFields((CsvField) field);</span>

<span class="fc" id="L119">            session.head().setSourceField(readField);</span>
<span class="fc" id="L120">            return readField;</span>
        }
    }

    private Field readFields(CsvField field) throws AtlasException {
<span class="fc" id="L125">        List&lt;Field&gt; fields = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L126">        CsvField csvField = field;</span>
<span class="fc" id="L127">        CSVFormat csvFormat = csvConfig.newCsvFormat();</span>
        try {
<span class="fc" id="L129">            document.mark(Integer.MAX_VALUE);</span>

<span class="fc" id="L131">            CSVParser parser = csvFormat.parse(new InputStreamReader(document));</span>

<span class="fc" id="L133">            AtlasPath atlasPath = new AtlasPath(csvField.getPath());</span>
<span class="fc" id="L134">            int i = 0;</span>
<span class="fc" id="L135">            Integer fieldIndex = atlasPath.getRootSegment().getCollectionIndex();</span>
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">            if (fieldIndex != null) {</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">                for (CSVRecord record: parser) {</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">                    if (i == fieldIndex) {</span>
<span class="nc" id="L139">                        CsvField newField = CsvField.cloneOf(csvField);</span>
<span class="nc" id="L140">                        newField.setIndex(null); //do not copy over index if set</span>
                        String value;
<span class="nc bnc" id="L142" title="All 2 branches missed.">                        if (csvField.getColumn() != null) {</span>
<span class="nc" id="L143">                            value = record.get(csvField.getColumn());</span>
                        } else {
<span class="nc" id="L145">                            value = record.get(csvField.getName());</span>
                        }
<span class="nc" id="L147">                        newField.setValue(value);</span>
<span class="nc" id="L148">                        fields.add(newField);</span>
<span class="nc" id="L149">                        break;</span>
                    }
<span class="nc" id="L151">                    i++;</span>
<span class="nc" id="L152">                }</span>
            } else {
<span class="fc bfc" id="L154" title="All 2 branches covered.">                for (CSVRecord record: parser) {</span>
<span class="fc" id="L155">                    CsvField collectionField = CsvField.cloneOf(csvField);</span>
<span class="fc" id="L156">                    collectionField.setIndex(null); //do not copy over index if set</span>
                    String value;
<span class="fc bfc" id="L158" title="All 2 branches covered.">                    if (csvField.getColumn() != null) {</span>
<span class="fc" id="L159">                        value = record.get(csvField.getColumn());</span>
                    } else {
<span class="fc" id="L161">                        value = record.get(csvField.getName());</span>
                    }
<span class="fc" id="L163">                    collectionField.setValue(value);</span>
<span class="fc" id="L164">                    AtlasPath collectionFieldPath = new AtlasPath(collectionField.getPath());</span>
<span class="fc" id="L165">                    collectionFieldPath.setCollectionIndex(0, i);</span>
<span class="fc" id="L166">                    collectionField.setPath(collectionFieldPath.toString());</span>
<span class="fc" id="L167">                    fields.add(collectionField);</span>
<span class="fc" id="L168">                    i++;</span>
<span class="fc" id="L169">                }</span>
            }

<span class="fc" id="L172">            document.reset();</span>
<span class="nc" id="L173">        } catch (IOException e) {</span>
<span class="nc" id="L174">            throw new AtlasException(e);</span>
<span class="fc" id="L175">        }</span>

<span class="pc bpc" id="L177" title="1 of 2 branches missed.">        if (fields.size() == 1) {</span>
<span class="nc" id="L178">            return fields.get(0);</span>
        } else {
<span class="fc" id="L180">            FieldGroup fieldGroup = AtlasModelFactory.createFieldGroupFrom(field, true);</span>
<span class="fc" id="L181">            fieldGroup.getField().addAll(fields);</span>
<span class="fc" id="L182">            return fieldGroup;</span>
        }

    }

    /**
     * Reads only the first row of the document.
     *
     * If firstRecordAsHeader is set to true it uses column names for field names, otherwise it uses an index
     * starting from 0.
     *
     * @return {@link Document} built from CSV
     * @throws AtlasException if it fails
     */
    public Document readSchema() throws AtlasException {
<span class="fc" id="L197">        CSVFormat csvFormat = csvConfig.newCsvFormat();</span>
        CSVParser parser;
        try {
<span class="fc" id="L200">            document.mark(Integer.MAX_VALUE);</span>
<span class="fc" id="L201">            parser = csvFormat.parse(new InputStreamReader(document));</span>

<span class="nc" id="L203">        } catch (IOException e) {</span>
<span class="nc" id="L204">            throw new AtlasException(e);</span>
<span class="fc" id="L205">        }</span>

<span class="fc" id="L207">        List&lt;CsvField&gt; fields = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">        if (csvConfig.isFirstRecordAsHeader()) {</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">            for (String headerName : parser.getHeaderNames()) {</span>
<span class="fc" id="L210">                CsvField field = new CsvField();</span>
<span class="fc" id="L211">                field.setName(headerName);</span>
<span class="fc" id="L212">                field.setPath(&quot;/&lt;&gt;/&quot; + headerName);</span>
<span class="fc" id="L213">                field.setFieldType(FieldType.STRING);</span>
<span class="fc" id="L214">                fields.add(field);</span>
<span class="fc" id="L215">            }</span>
        } else {
<span class="fc" id="L217">            CSVRecord record = parser.iterator().next();</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">            for (int i = 0; i &lt; record.size(); i++) {</span>
<span class="fc" id="L219">                CsvField field = new CsvField();</span>
<span class="pc bpc" id="L220" title="1 of 4 branches missed.">                if (parser.getHeaderNames() != null &amp;&amp; parser.getHeaderNames().size() &gt; i) {</span>
<span class="fc" id="L221">                    field.setName(parser.getHeaderNames().get(i));</span>
                } else {
<span class="fc" id="L223">                    field.setColumn(i);</span>
<span class="fc" id="L224">                    field.setName(String.valueOf(i));</span>
                }
<span class="fc" id="L226">                field.setPath(&quot;/&lt;&gt;/&quot; + field.getName());</span>
<span class="fc" id="L227">                field.setFieldType(FieldType.STRING);</span>
<span class="fc" id="L228">                fields.add(field);</span>
            }
        }

        try {
<span class="fc" id="L233">            document.reset();</span>
<span class="nc" id="L234">        } catch (IOException e) {</span>
<span class="nc" id="L235">            throw new AtlasException(e);</span>
<span class="fc" id="L236">        }</span>

<span class="fc" id="L238">        CsvFields csvFields = new CsvFields();</span>
<span class="fc" id="L239">        csvFields.getCsvField().addAll(fields);</span>

<span class="fc" id="L241">        CsvComplexType csvComplexType = new CsvComplexType();</span>
<span class="fc" id="L242">        csvComplexType.setFieldType(FieldType.COMPLEX);</span>
<span class="fc" id="L243">        csvComplexType.setCollectionType(CollectionType.LIST);</span>
<span class="fc" id="L244">        csvComplexType.setPath(&quot;/&lt;&gt;&quot;);</span>
<span class="fc" id="L245">        csvComplexType.setName(&quot;&quot;);</span>
<span class="fc" id="L246">        csvComplexType.setCsvFields(csvFields);</span>

<span class="fc" id="L248">        Fields documentFields = new Fields();</span>
<span class="fc" id="L249">        documentFields.getField().add(csvComplexType);</span>

<span class="fc" id="L251">        Document document = new Document();</span>
<span class="fc" id="L252">        document.setFields(documentFields);</span>
<span class="fc" id="L253">        return document;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>