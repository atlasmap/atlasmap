<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>CsvFieldReader.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Unit Test Coverage Report</a> &gt; <a href="../index.html" class="el_bundle">atlas-csv-core</a> &gt; <a href="index.source.html" class="el_package">io.atlasmap.csv.core</a> &gt; <span class="el_source">CsvFieldReader.java</span></div><h1>CsvFieldReader.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2017 Red Hat, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.atlasmap.csv.core;

import io.atlasmap.api.AtlasException;
import io.atlasmap.core.AtlasPath;
import io.atlasmap.core.AtlasUtil;
import io.atlasmap.csv.v2.CsvComplexType;
import io.atlasmap.csv.v2.CsvField;
import io.atlasmap.csv.v2.CsvFields;
import io.atlasmap.spi.AtlasFieldReader;
import io.atlasmap.spi.AtlasInternalSession;
import io.atlasmap.v2.AtlasModelFactory;
import io.atlasmap.v2.AuditStatus;
import io.atlasmap.v2.CollectionType;
import io.atlasmap.v2.Document;
import io.atlasmap.v2.Field;
import io.atlasmap.v2.FieldGroup;
import io.atlasmap.v2.FieldType;
import io.atlasmap.v2.Fields;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVRecord;
import sun.misc.IOUtils;

import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;

/**
 * It accepts InputStream as a document in order to process big files efficiently.
 * It uses the mark operation of the InputStream to reset the stream and read consecutive fields.
 * If InputStream does not support the mark operation it is wrapped in BufferedInputStream.
 */
public class CsvFieldReader implements AtlasFieldReader {

    private final CsvConfig csvConfig;
    private InputStream document;

<span class="fc" id="L56">    public CsvFieldReader(CsvConfig csvConfig) {</span>
<span class="fc" id="L57">        this.csvConfig = csvConfig;</span>
<span class="fc" id="L58">    }</span>

    public void setDocument(InputStream inputStream) {
<span class="pc bpc" id="L61" title="1 of 4 branches missed.">        if (inputStream != null &amp;&amp; !inputStream.markSupported()) {</span>
<span class="nc" id="L62">            this.document = new BufferedInputStream(inputStream);</span>
        } else {
<span class="fc" id="L64">            this.document = inputStream;</span>
        }
<span class="fc" id="L66">    }</span>

    @Override
    public Field read(AtlasInternalSession session) throws AtlasException {
<span class="fc" id="L70">        Field field = session.head().getSourceField();</span>

<span class="fc bfc" id="L72" title="All 2 branches covered.">        if (document == null) {</span>
<span class="fc" id="L73">            AtlasUtil.addAudit(session, field.getDocId(),</span>
<span class="fc" id="L74">                String.format(&quot;Cannot read field '%s' of document '%s', document is null&quot;,</span>
<span class="fc" id="L75">                    field.getPath(), field.getDocId()),</span>
<span class="fc" id="L76">                field.getPath(), AuditStatus.ERROR, null);</span>
<span class="fc" id="L77">            return field;</span>
        }
<span class="pc bpc" id="L79" title="1 of 2 branches missed.">        if (field == null) {</span>
<span class="nc" id="L80">            throw new AtlasException(new IllegalArgumentException(&quot;Argument 'field' cannot be null&quot;));</span>
        }
<span class="pc bpc" id="L82" title="3 of 4 branches missed.">        if (!(field instanceof CsvField) &amp;&amp; !(field instanceof FieldGroup)) {</span>
<span class="nc" id="L83">            throw new AtlasException(String.format(&quot;Unsupported field type '%s'&quot;, field.getClass()));</span>
        }

<span class="pc bpc" id="L86" title="1 of 2 branches missed.">        if (field instanceof FieldGroup) {</span>
            //complex field
<span class="nc" id="L88">            FieldGroup fieldGroup = (FieldGroup) field;</span>
<span class="nc" id="L89">            List&lt;Field&gt; fields = fieldGroup.getField();</span>

<span class="nc" id="L91">            FieldGroup readFieldGroup = AtlasModelFactory.copyFieldGroup(fieldGroup);</span>

<span class="nc bnc" id="L93" title="All 2 branches missed.">            for (Field subField: fields) {</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">                if (subField instanceof FieldGroup) {</span>
                    //support only one level grouping
<span class="nc" id="L96">                    subField = ((FieldGroup) subField).getField().get(0);</span>
                }

<span class="nc bnc" id="L99" title="All 2 branches missed.">                if (subField instanceof CsvField) {</span>
<span class="nc" id="L100">                    Field readSubField = readFields((CsvField) subField);</span>
<span class="nc" id="L101">                    readFieldGroup.getField().add(readSubField);</span>
                }
<span class="nc" id="L103">            }</span>

<span class="nc" id="L105">            session.head().setSourceField(readFieldGroup);</span>
<span class="nc" id="L106">            return readFieldGroup;</span>
        } else {
<span class="fc" id="L108">            Field readField = readFields((CsvField) field);</span>

<span class="fc" id="L110">            session.head().setSourceField(readField);</span>
<span class="fc" id="L111">            return readField;</span>
        }
    }

    private Field readFields(CsvField field) throws AtlasException {
<span class="fc" id="L116">        List&lt;Field&gt; fields = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L117">        CsvField csvField = field;</span>
<span class="fc" id="L118">        CSVFormat csvFormat = csvConfig.newCsvFormat();</span>
        try {
<span class="fc" id="L120">            document.mark(Integer.MAX_VALUE);</span>

<span class="fc" id="L122">            CSVParser parser = csvFormat.parse(new InputStreamReader(document));</span>

<span class="fc" id="L124">            AtlasPath atlasPath = new AtlasPath(csvField.getPath());</span>
<span class="fc" id="L125">            int i = 0;</span>
<span class="fc" id="L126">            Integer fieldIndex = atlasPath.getRootSegment().getCollectionIndex();</span>
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">            if (fieldIndex != null) {</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">                for (CSVRecord record: parser) {</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">                    if (i == fieldIndex) {</span>
<span class="nc" id="L130">                        CsvField newField = CsvField.cloneOf(csvField);</span>
                        String value;
<span class="nc bnc" id="L132" title="All 2 branches missed.">                        if (csvField.getColumn() != null) {</span>
<span class="nc" id="L133">                            value = record.get(csvField.getColumn());</span>
                        } else {
<span class="nc" id="L135">                            value = record.get(csvField.getName());</span>
                        }
<span class="nc" id="L137">                        newField.setValue(value);</span>
<span class="nc" id="L138">                        fields.add(newField);</span>
<span class="nc" id="L139">                        break;</span>
                    }
<span class="nc" id="L141">                    i++;</span>
<span class="nc" id="L142">                }</span>
            } else {
<span class="fc bfc" id="L144" title="All 2 branches covered.">                for (CSVRecord record: parser) {</span>
<span class="fc" id="L145">                    CsvField collectionField = CsvField.cloneOf(csvField);</span>
                    String value;
<span class="fc bfc" id="L147" title="All 2 branches covered.">                    if (csvField.getColumn() != null) {</span>
<span class="fc" id="L148">                        value = record.get(csvField.getColumn());</span>
                    } else {
<span class="fc" id="L150">                        value = record.get(csvField.getName());</span>
                    }
<span class="fc" id="L152">                    collectionField.setValue(value);</span>
<span class="fc" id="L153">                    AtlasPath collectionFieldPath = new AtlasPath(collectionField.getPath());</span>
<span class="fc" id="L154">                    collectionFieldPath.setCollectionIndex(0, i);</span>
<span class="fc" id="L155">                    collectionField.setPath(collectionFieldPath.toString());</span>
<span class="fc" id="L156">                    fields.add(collectionField);</span>
<span class="fc" id="L157">                    i++;</span>
<span class="fc" id="L158">                }</span>
            }

<span class="fc" id="L161">            document.reset();</span>
<span class="nc" id="L162">        } catch (IOException e) {</span>
<span class="nc" id="L163">            throw new AtlasException(e);</span>
<span class="fc" id="L164">        }</span>

<span class="pc bpc" id="L166" title="1 of 2 branches missed.">        if (fields.size() == 1) {</span>
<span class="nc" id="L167">            return fields.get(0);</span>
        } else {
<span class="fc" id="L169">            FieldGroup fieldGroup = AtlasModelFactory.createFieldGroupFrom(field, true);</span>
<span class="fc" id="L170">            fieldGroup.getField().addAll(fields);</span>
<span class="fc" id="L171">            return fieldGroup;</span>
        }

    }

    /**
     * Reads only the first row of the document.
     *
     * If firstRecordAsHeader is set to true it uses column names for field names, otherwise it uses an index
     * starting from 0.
     *
     * @return
     * @throws AtlasException
     */
    public Document readSchema() throws AtlasException {
<span class="fc" id="L186">        CSVFormat csvFormat = csvConfig.newCsvFormat();</span>
        CSVParser parser;
        try {
<span class="fc" id="L189">            document.mark(Integer.MAX_VALUE);</span>
<span class="fc" id="L190">            parser = csvFormat.parse(new InputStreamReader(document));</span>

<span class="nc" id="L192">        } catch (IOException e) {</span>
<span class="nc" id="L193">            throw new AtlasException(e);</span>
<span class="fc" id="L194">        }</span>

<span class="fc" id="L196">        List&lt;CsvField&gt; fields = new ArrayList&lt;&gt;();</span>

<span class="pc bpc" id="L198" title="1 of 2 branches missed.">        if (csvConfig.isFirstRecordAsHeader()) {</span>
<span class="fc" id="L199">            int i = 0;</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">            for (String headerName : parser.getHeaderNames()) {</span>
<span class="fc" id="L201">                CsvField field = new CsvField();</span>
<span class="fc" id="L202">                field.setColumn(i);</span>
<span class="fc" id="L203">                field.setName(headerName);</span>
<span class="fc" id="L204">                field.setPath(&quot;/&lt;&gt;/&quot; + headerName);</span>
<span class="fc" id="L205">                field.setFieldType(FieldType.STRING);</span>
<span class="fc" id="L206">                fields.add(field);</span>
<span class="fc" id="L207">                i++;</span>
<span class="fc" id="L208">            }</span>
<span class="fc" id="L209">        } else {</span>
<span class="nc" id="L210">            CSVRecord record = parser.iterator().next();</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">            for (int i = 0; i &lt; record.size(); i++) {</span>
<span class="nc" id="L212">                CsvField field = new CsvField();</span>
<span class="nc" id="L213">                field.setColumn(i);</span>
<span class="nc" id="L214">                field.setName(String.valueOf(i));</span>
<span class="nc" id="L215">                field.setPath(&quot;/&lt;&gt;/&quot; + field.getName());</span>
<span class="nc" id="L216">                field.setFieldType(FieldType.STRING);</span>
<span class="nc" id="L217">                fields.add(field);</span>
            }
        }

        try {
<span class="fc" id="L222">            document.reset();</span>
<span class="nc" id="L223">        } catch (IOException e) {</span>
<span class="nc" id="L224">            throw new AtlasException(e);</span>
<span class="fc" id="L225">        }</span>

<span class="fc" id="L227">        CsvFields csvFields = new CsvFields();</span>
<span class="fc" id="L228">        csvFields.getCsvField().addAll(fields);</span>

<span class="fc" id="L230">        CsvComplexType csvComplexType = new CsvComplexType();</span>
<span class="fc" id="L231">        csvComplexType.setFieldType(FieldType.COMPLEX);</span>
<span class="fc" id="L232">        csvComplexType.setCollectionType(CollectionType.LIST);</span>
<span class="fc" id="L233">        csvComplexType.setPath(&quot;/&lt;&gt;&quot;);</span>
<span class="fc" id="L234">        csvComplexType.setName(&quot;&quot;);</span>
<span class="fc" id="L235">        csvComplexType.setCsvFields(csvFields);</span>

<span class="fc" id="L237">        Fields documentFields = new Fields();</span>
<span class="fc" id="L238">        documentFields.getField().add(csvComplexType);</span>

<span class="fc" id="L240">        Document document = new Document();</span>
<span class="fc" id="L241">        document.setFields(documentFields);</span>
<span class="fc" id="L242">        return document;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>