<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AtlasService.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Unit Test Coverage Report</a> &gt; <a href="../index.html" class="el_bundle">atlas-service</a> &gt; <a href="index.source.html" class="el_package">io.atlasmap.service</a> &gt; <span class="el_source">AtlasService.java</span></div><h1>AtlasService.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2017 Red Hat, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.atlasmap.service;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.InputStream;
import java.nio.file.Paths;
import java.util.ArrayList;

import javax.ws.rs.Consumes;
import javax.ws.rs.DELETE;
import javax.ws.rs.GET;
import javax.ws.rs.PUT;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.Status;
import javax.ws.rs.core.UriBuilder;
import javax.ws.rs.core.UriInfo;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.atlasmap.api.AtlasContextFactory;
import io.atlasmap.api.AtlasException;
import io.atlasmap.api.AtlasMappingBuilder;
import io.atlasmap.core.ADMArchiveHandler;
import io.atlasmap.core.AtlasUtil;
import io.atlasmap.core.DefaultAtlasContextFactory;
import io.atlasmap.core.DefaultAtlasFieldActionService;
import io.atlasmap.service.AtlasLibraryLoader.AtlasLibraryLoaderListener;
import io.atlasmap.v2.ActionDetails;
import io.atlasmap.v2.AtlasMapping;
import io.atlasmap.v2.StringMap;
import io.atlasmap.v2.StringMapEntry;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.parameters.RequestBody;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;

/**
 * {@link AtlasService}, {@link MappingService} and {@link DocumentService} provide core backend REST services which
 * is not specific to the individual data formats.
 * {@link MappingService} handles mappings, {@link DocumentService} handles Documents (data sources in other words), and
 * {@link AtlasService} handles the rest such as field action, library, ADM Digest file and ADM archive file.
 */
@Path(&quot;/&quot;)
public class AtlasService extends BaseAtlasService {
    /** Mapping name prefix. */
    static final String MAPPING_NAME_PREFIX = &quot;UI.&quot;;
    /** The property name for the ADM Archive file to preload. */
    static final String ATLASMAP_ADM_PATH = &quot;atlasmap.adm.path&quot;;
    /** The property name for the AtlasMap design time service backend working directory. */
    static final String ATLASMAP_WORKSPACE = &quot;atlasmap.workspace&quot;;
<span class="fc" id="L77">    private static final Logger LOG = LoggerFactory.getLogger(AtlasService.class);</span>

<span class="fc" id="L79">    private final DefaultAtlasContextFactory atlasContextFactory = DefaultAtlasContextFactory.getInstance();</span>

<span class="fc" id="L81">    private String baseFolder = &quot;&quot;;</span>
<span class="fc" id="L82">    private String mappingFolder = &quot;&quot;;</span>
<span class="fc" id="L83">    private String libFolder = &quot;&quot;;</span>

    /**
     * A constructor.
     * @throws AtlasException unexpected error
     */
<span class="fc" id="L89">    public AtlasService() throws AtlasException {</span>
<span class="fc" id="L90">        String atlasmapWorkspace = System.getProperty(ATLASMAP_WORKSPACE);</span>
<span class="fc" id="L91">        LOG.debug(&quot;AtlasMap backend Working directory: {}&quot;, atlasmapWorkspace);</span>
<span class="pc bpc" id="L92" title="1 of 4 branches missed.">        if (atlasmapWorkspace != null &amp;&amp; atlasmapWorkspace.length() &gt; 0) {</span>
<span class="fc" id="L93">            baseFolder = atlasmapWorkspace;</span>
        } else {
<span class="fc" id="L95">            baseFolder = &quot;target&quot;;</span>
        }

<span class="fc" id="L98">        mappingFolder = baseFolder + File.separator + &quot;mappings&quot;;</span>
<span class="fc" id="L99">        libFolder = baseFolder + File.separator + &quot;lib&quot;;</span>

<span class="fc" id="L101">        setLibraryLoader(new AtlasLibraryLoader(libFolder));</span>

        // Add atlas-core in case it runs on modular class loader
<span class="fc" id="L104">        getLibraryLoader().addAlternativeLoader(DefaultAtlasFieldActionService.class.getClassLoader());</span>
<span class="fc" id="L105">        getLibraryLoader().addListener(new AtlasLibraryLoaderListener() {</span>
            @Override
            public void onUpdate(AtlasLibraryLoader loader) {
<span class="fc" id="L108">                synchronized (atlasContextFactory) {</span>
<span class="fc" id="L109">                    ((DefaultAtlasContextFactory) atlasContextFactory).destroy();</span>
<span class="fc" id="L110">                    ((DefaultAtlasContextFactory) atlasContextFactory).init(getLibraryLoader());</span>
<span class="fc" id="L111">                }</span>
<span class="fc" id="L112">            }</span>
        });

<span class="fc" id="L115">        String atlasmapAdmPath = System.getProperty(ATLASMAP_ADM_PATH);</span>
<span class="pc bpc" id="L116" title="3 of 4 branches missed.">        if (atlasmapAdmPath != null &amp;&amp; atlasmapAdmPath.length() &gt; 0) {</span>
<span class="nc" id="L117">            LOG.debug(&quot;Loading initial ADM file: {}&quot;, atlasmapAdmPath);</span>
<span class="nc" id="L118">            getLibraryLoader().clearLibraries();</span>
<span class="nc" id="L119">            ADMArchiveHandler admHandler = new ADMArchiveHandler(getLibraryLoader());</span>
<span class="nc" id="L120">            java.nio.file.Path mappingDirPath = Paths.get(getMappingSubDirectory(0));</span>
<span class="nc" id="L121">            admHandler.setPersistDirectory(mappingDirPath);</span>
<span class="nc" id="L122">            admHandler.setIgnoreLibrary(false);</span>
<span class="nc" id="L123">            admHandler.setLibraryDirectory(Paths.get(libFolder));</span>
<span class="nc" id="L124">            admHandler.load(Paths.get(atlasmapAdmPath));</span>
<span class="nc" id="L125">            getLibraryLoader().reload();</span>
<span class="nc" id="L126">            admHandler.persist();</span>
        }

<span class="fc" id="L129">        synchronized (atlasContextFactory) {</span>
<span class="fc" id="L130">            ((DefaultAtlasContextFactory) atlasContextFactory).destroy();</span>
<span class="fc" id="L131">            ((DefaultAtlasContextFactory) atlasContextFactory).init(getLibraryLoader());</span>
<span class="fc" id="L132">        }</span>
<span class="fc" id="L133">    }</span>

    /** Global operations */

    /**
     * Retrieves a list of available field action.
     * @param uriInfo URI info
     * @return {@link ActionDetails} serialized to JSON
     */
    @GET
    @Path(&quot;/fieldAction&quot;)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(summary = &quot;List FieldActions&quot;, description = &quot;Retrieves a list of available field action&quot;)
    @ApiResponses(@ApiResponse(responseCode = &quot;200&quot;, content = @Content(schema = @Schema(implementation = ActionDetails.class)), description = &quot;Return a list of field action detail&quot;))
    public Response listFieldActions(@Context UriInfo uriInfo) {
<span class="fc" id="L148">        ActionDetails details = new ActionDetails();</span>

<span class="pc bpc" id="L150" title="2 of 4 branches missed.">        if (atlasContextFactory == null || atlasContextFactory.getFieldActionService() == null) {</span>
<span class="nc" id="L151">            return Response.ok().entity(toJson(details)).build();</span>
        }

<span class="fc" id="L154">        details.getActionDetail().addAll(atlasContextFactory.getFieldActionService().listActionDetails());</span>
<span class="fc" id="L155">        byte[] serialized = toJson(details);</span>
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L157">            LOG.debug(new String(serialized));</span>
        }
<span class="fc" id="L159">        return Response.ok().entity(serialized).build();</span>
    }

    /**
     * Retrieves a list of mapping definition names from all existing mapping projects.
     * @param uriInfo URI info
     * @param filter filter
     * @return A list of mapping definition name in {@link StringMap}
     */
    @GET
    @Path(&quot;/project&quot;)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(summary = &quot;List Mapping Definition names&quot;, description = &quot;Retrieves a list of mapping definition names&quot;)
    @ApiResponses(@ApiResponse(responseCode = &quot;200&quot;, content = @Content(schema = @Schema(implementation = StringMap.class)) , description = &quot;Return a list of mapping definition names&quot;))
    public Response listMappingDefinitionNames(@Context UriInfo uriInfo, @QueryParam(&quot;filter&quot;) final String filter) {
<span class="fc" id="L174">        StringMap sMap = new StringMap();</span>
<span class="fc" id="L175">        LOG.debug(&quot;listMappingDefinitionNames - filter is not supported, ignoring '{}'&quot;, filter);</span>

<span class="fc" id="L177">        java.nio.file.Path mappingFolderPath = Paths.get(mappingFolder);</span>
<span class="fc" id="L178">        File mappingFolderPathFile = mappingFolderPath.toFile();</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">        if (mappingFolderPathFile.exists()) {</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">            for (String id : mappingFolderPathFile.list()) {</span>
                Integer mappingDefinitionId;
                try {
<span class="fc" id="L183">                    mappingDefinitionId = Integer.parseInt(id);</span>
<span class="nc" id="L184">                } catch (Exception e) {</span>
<span class="nc" id="L185">                    continue;</span>
<span class="fc" id="L186">                }</span>
<span class="fc" id="L187">                ADMArchiveHandler handler = loadExplodedMappingDirectory(mappingDefinitionId);</span>
<span class="fc" id="L188">                AtlasMapping map = handler.getMappingDefinition();</span>
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">                if (map == null) {</span>
<span class="nc" id="L190">                    continue;</span>
                }
<span class="fc" id="L192">                StringMapEntry mapEntry = new StringMapEntry();</span>
<span class="fc" id="L193">                mapEntry.setName(map.getName());</span>
<span class="fc" id="L194">                UriBuilder builder = uriInfo.getBaseUriBuilder().path(&quot;v2&quot;).path(&quot;atlas&quot;).path(&quot;project&quot;)</span>
<span class="fc" id="L195">                        .path(id).path(&quot;mapping&quot;);</span>
<span class="fc" id="L196">                mapEntry.setValue(builder.build().toString());</span>
<span class="fc" id="L197">                sMap.getStringMapEntry().add(mapEntry);</span>
            }
        }
<span class="fc" id="L200">        byte[] serialized = toJson(sMap);</span>
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L202">            LOG.debug(new String(serialized));</span>
        }
<span class="fc" id="L204">        return Response.ok().entity(serialized).build();</span>
    }

    /**
     * Delete all mapping projects including Mapping Definitions and Documents saved on the server.
     * @return empty response
     */
    @DELETE
    @Path(&quot;/project&quot;)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(summary = &quot;Delete All Mapping projects&quot;, description = &quot;Delete all mapping projects including Mapping Definitions and Documents saved on the server&quot;)
    @ApiResponses({
            @ApiResponse(responseCode = &quot;200&quot;, description = &quot;All mapping projects were deleted successfully&quot;),
            @ApiResponse(responseCode = &quot;204&quot;, description = &quot;Unable to delete all mapping projects&quot;) })
    public Response deleteAllMappingProjects() {
<span class="fc" id="L219">        LOG.debug(&quot;deleteAllMappingProjects&quot;);</span>

<span class="fc" id="L221">        java.nio.file.Path mappingFolderPath = Paths.get(mappingFolder);</span>
<span class="fc" id="L222">        File mappingFolderPathFile = mappingFolderPath.toFile();</span>

<span class="pc bpc" id="L224" title="1 of 4 branches missed.">        if (mappingFolderPathFile == null || !mappingFolderPathFile.exists()) {</span>
<span class="fc" id="L225">            return Response.ok().build();</span>
        }

<span class="fc" id="L228">        AtlasUtil.deleteDirectoryContents(mappingFolderPathFile);</span>
<span class="fc" id="L229">        return Response.ok().build();</span>
    }

    /**
     * Retrieves AtlasMap core library version.
     * @return version
     */
    @GET
    @Path(&quot;/version&quot;)
    @Operation(summary = &quot;Version&quot;, description = &quot;Retrieves AtlasMap core library version.&quot;)
    @ApiResponses(@ApiResponse(responseCode = &quot;200&quot;, content = @Content(schema = @Schema(type = &quot;string&quot;)), description = &quot;Return 'pong'&quot;))
    public Response version() {
<span class="fc" id="L241">        String version = this.atlasContextFactory.getProperties()</span>
<span class="fc" id="L242">                .get(AtlasContextFactory.PROPERTY_ATLASMAP_CORE_VERSION);</span>
<span class="fc" id="L243">        LOG.debug(&quot;Answering AtlasMap version: {}&quot;, version);</span>
<span class="fc" id="L244">        return Response.ok().entity(toJson(version)).build();</span>
    }

    /**
     * Uploads a Java library archive file (jar).
     * @param requestIn request
     * @return empty response
     */
    @PUT
    @Path(&quot;/library&quot;)
    @Operation(summary = &quot;Upload Library&quot;, description = &quot;Upload a Java library archive file&quot;)
    @Consumes({ MediaType.APPLICATION_OCTET_STREAM })
    @ApiResponses(@ApiResponse(responseCode = &quot;200&quot;, description = &quot;Library upload successful.&quot;))
    public Response uploadLibrary(InputStream requestIn) {
<span class="pc bpc" id="L258" title="1 of 2 branches missed.">        if (requestIn == null) {</span>
<span class="nc" id="L259">            throw new WebApplicationException(&quot;No library file found in request body&quot;);</span>
        }

        try {
<span class="fc" id="L263">            getLibraryLoader().addJarFromStream(requestIn);</span>
<span class="fc" id="L264">        } catch (Exception e) {</span>
<span class="pc bpc" id="L265" title="1 of 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L266">                LOG.error(&quot;&quot;, e);</span>
            }
<span class="fc" id="L268">            StringBuilder buf = new StringBuilder();</span>
<span class="fc" id="L269">            buf.append(&quot;Failed to import a jar file. This error occurs when:\n&quot;)</span>
<span class="fc" id="L270">                    .append((&quot;\t1. The jar file is not compatible with the JVM which AtlasMap backend server is running on\n&quot;))</span>
<span class="fc" id="L271">                    .append(&quot;\t2. The jar file is broken\n&quot;)</span>
<span class="fc" id="L272">                    .append(&quot;\t3. There is a missing file under META-INF/services, i.e. Java service declaration for custom transformation, custom transformation model, custom mapping builder, etc\n&quot;);</span>
<span class="fc" id="L273">            throw new WebApplicationException(buf.toString(), e);</span>
<span class="fc" id="L274">        }</span>
<span class="fc" id="L275">        return Response.ok().build();</span>
    }

    /**
     * Removes all user-defined JAR files saved on the server.
     * @return empty response
     */
    @DELETE
    @Path(&quot;/library&quot;)
    @Operation(summary = &quot;Remove All User-Defined JAR libraries&quot;, description = &quot;Remove all user-defined JAR files saved on the server&quot;)
    @ApiResponses({
            @ApiResponse(responseCode = &quot;200&quot;, description = &quot;All user-defined JAR files were removed successfully&quot;),
            @ApiResponse(responseCode = &quot;204&quot;, description = &quot;Unable to remove all user-defined JAR files&quot;) })
    public Response deleteLibraries() {
<span class="fc" id="L289">        LOG.debug(&quot;deleteLibraries&quot;);</span>
<span class="fc" id="L290">        getLibraryLoader().clearLibraries();</span>
<span class="fc" id="L291">        return Response.ok().build();</span>
    }

    /**
     * Retrieves a list of available Java library class names from uploaded JARs.
     * @param uriInfo URI info
     * @return class names
     */
    @GET
    @Path(&quot;/library/class&quot;)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(summary = &quot;List Library Classes&quot;, description = &quot;Retrieves a list of available Java library class names from uploaded JARs.&quot;)
    @ApiResponses(@ApiResponse(responseCode = &quot;200&quot;, content = @Content(schema = @Schema(type = &quot;ArrayList&lt;String&gt;&quot;)), description = &quot;Return a list of loadable class names&quot;))
    public Response listLibraryClasses(@Context UriInfo uriInfo) {
        ArrayList&lt;String&gt; classNames;
        try {
<span class="nc" id="L307">            classNames = getLibraryLoader().getLibraryClassNames();</span>
<span class="nc" id="L308">        } catch (Exception e) {</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L310">                LOG.error(&quot;Library class retrieval error.&quot;, e);</span>
            }
<span class="nc" id="L312">            throw new WebApplicationException(&quot;Error retrieving class names from uploaded JARs.&quot;);</span>
<span class="nc" id="L313">        }</span>
<span class="nc" id="L314">        byte[] serialized = toJson(classNames);</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L316">            LOG.debug(new String(serialized));</span>
        }
<span class="nc" id="L318">        return Response.ok().entity(serialized).build();</span>
    }

    /**
     * List mapping builder classes which defines custom mapping logic.
     * @param uriInfo URI info
     * @return class names
     */
    @GET
    @Path(&quot;/library/class/mappingBuilder&quot;)
    @Operation(summary = &quot;List mapping builder classes&quot;, description = &quot;List mapping builder classes which defines custom mapping logic&quot;)
    @Produces(MediaType.APPLICATION_JSON)
    @ApiResponses(@ApiResponse(responseCode = &quot;200&quot;, content = @Content(schema = @Schema(type = &quot;ArrayList&lt;String&gt;&quot;)), description = &quot;Return a list of loadable class names&quot;))
    public Response listMappingBuilderClasses(@Context UriInfo uriInfo) {
        ArrayList&lt;String&gt; classNames;
        try {
<span class="fc" id="L334">            classNames = getLibraryLoader().getSubTypesOf(AtlasMappingBuilder.class, false);</span>
<span class="nc" id="L335">        } catch (Exception e) {</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L337">                LOG.error(&quot;Library class retrieval error.&quot;, e);</span>
            }
<span class="nc" id="L339">            throw new WebApplicationException(&quot;Error retrieving class names from uploaded JARs.&quot;);</span>
<span class="fc" id="L340">        }</span>
<span class="fc" id="L341">        byte[] serialized = toJson(classNames);</span>
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L343">            LOG.debug(new String(serialized));</span>
        }
<span class="fc" id="L345">        return Response.ok().entity(serialized).build();</span>
    }

    /**
     * Delete all user-defined library JAR files and mapping projects including Mapping Definitions and Documents saved on the server.
     * @return empty response
     */
    @DELETE
    @Path(&quot;/all&quot;)
    @Operation(summary = &quot;Delete all&quot;, description = &quot;Delete all user-defined library JAR files and mapping projects&quot;)
    @ApiResponses({
        @ApiResponse(responseCode = &quot;200&quot;, description = &quot;All user-defined libarary JARs and mapping projects were deleted successfully&quot;),
        @ApiResponse(responseCode = &quot;204&quot;, description = &quot;Unable to delete all user-defined JAR files and mapping projects&quot;) })
    public Response deleteAll() {
<span class="fc" id="L359">        LOG.debug(&quot;deleteAll&quot;);</span>
<span class="fc" id="L360">        getLibraryLoader().clearLibraries();</span>
<span class="fc" id="L361">        deleteAllMappingProjects();</span>
<span class="fc" id="L362">        return Response.ok().build();</span>
    }

    /**
     * Simple liveness check method used in liveness checks. Must not be protected via authetication.
     * @return pong
     */
    @GET
    @Path(&quot;/ping&quot;)
    @Operation(summary = &quot;Ping&quot;, description = &quot;Simple liveness check method used in liveness checks. Must not be protected via authetication.&quot;)
    @ApiResponses(@ApiResponse(responseCode = &quot;200&quot;, content = @Content(schema = @Schema(type = &quot;string&quot;)), description = &quot;Return 'pong'&quot;))
    public Response ping() {
<span class="fc" id="L374">        LOG.debug(&quot;Ping...  responding with 'pong'.&quot;);</span>
<span class="fc" id="L375">        return Response.ok().entity(toJson(&quot;pong&quot;)).build();</span>
    }

    /** Per project operations */

    /**
     * Removes the mapping project including a Mapping Definition and Documents related to specified ID.
     * @param mappingDefinitionId mapping definition ID
     * @return empty response
     */
    @DELETE
    @Path(&quot;/project/{mappingDefinitionId}&quot;)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(summary = &quot;Delete Mapping Project by ID&quot;, description = &quot;Delete the mapping project including a Mapping Definition and Documents related to specified ID&quot;)
    @ApiResponses({
            @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Mapping project was removed successfully&quot;),
            @ApiResponse(responseCode = &quot;204&quot;, description = &quot;Unable to remove a mapping project for the specified ID&quot;) })
    public Response deleteMappingProjectById(
            @Parameter(description = &quot;Mapping Definition ID&quot;) @PathParam(&quot;mappingDefinitionId&quot;) Integer mappingDefinitionId) {
<span class="nc" id="L394">        LOG.debug(&quot;deleteMappingProjectById {} &quot;, mappingDefinitionId);</span>

<span class="nc" id="L396">        java.nio.file.Path mappingFolderPath = Paths.get(getMappingSubDirectory(mappingDefinitionId));</span>
<span class="nc" id="L397">        File mappingFolderFile = mappingFolderPath.toFile();</span>

<span class="nc bnc" id="L399" title="All 4 branches missed.">        if (mappingFolderFile == null || !mappingFolderFile.exists()) {</span>
<span class="nc" id="L400">            return Response.ok().build();</span>
        }

<span class="nc bnc" id="L403" title="All 2 branches missed.">        if (!mappingFolderFile.isDirectory()) {</span>
<span class="nc" id="L404">            LOG.warn(&quot;{} is not a directory - removing anyway&quot;, mappingFolderFile.getAbsolutePath());</span>
        }
<span class="nc" id="L406">        AtlasUtil.deleteDirectory(mappingFolderFile);</span>
<span class="nc" id="L407">        return Response.ok().build();</span>
    }

    /**
     * Retrieve a gzipped ADM Digest file saved on the server.
     * @param mappingDefinitionId mapping definition ID
     * @return file
     */
    @GET
    @Path(&quot;/project/{mappingDefinitionId}/digest&quot;)
    @Produces({ MediaType.APPLICATION_OCTET_STREAM })
    @Operation(summary = &quot;Get ADM Digest file&quot;, description = &quot;Retrieve a gzipped ADM Digest file saved on the server&quot;)
    @ApiResponses({
            @ApiResponse(responseCode = &quot;200&quot;, content = @Content(mediaType = MediaType.APPLICATION_OCTET_STREAM), description = &quot;Return a gzipped ADM Digest file content&quot;),
            @ApiResponse(responseCode = &quot;204&quot;, description = &quot;ADM Digest file was not found&quot;),
            @ApiResponse(responseCode = &quot;500&quot;, description = &quot;ADM Digest file access error&quot;) })
    public Response getADMDigestRequest(
            @Parameter(description = &quot;Mapping definition ID&quot;) @PathParam(&quot;mappingDefinitionId&quot;) Integer mappingDefinitionId) {
<span class="fc" id="L425">        LOG.debug(&quot;getADMDigestRequest: {}&quot;, mappingDefinitionId);</span>
<span class="fc" id="L426">        ADMArchiveHandler admHandler = loadExplodedMappingDirectory(mappingDefinitionId);</span>

        try {
<span class="fc bfc" id="L429" title="All 2 branches covered.">            if (admHandler.getGzippedADMDigestBytes() == null) {</span>
<span class="fc" id="L430">                LOG.debug(&quot;ADM Digest file not found for ID:{}&quot;, mappingDefinitionId);</span>
<span class="fc" id="L431">                return Response.noContent().build();</span>
            }
<span class="fc" id="L433">            return Response.ok().entity(admHandler.getGzippedADMDigestBytes()).build();</span>
<span class="nc" id="L434">        } catch (Exception e) {</span>
<span class="nc" id="L435">            LOG.error(&quot;Error getting compressed ADM digest file.\n&quot; + e.getMessage(), e);</span>
<span class="nc" id="L436">            throw new WebApplicationException(e.getMessage(), e, Status.INTERNAL_SERVER_ERROR);</span>
        }
    }

    /**
     * Saves an ADM Digest file on the server.
     * @param mapping request payload
     * @param mappingDefinitionId mapping definition ID
     * @param uriInfo URI info
     * @return empty response
     */
    @PUT
    @Path(&quot;/project/{mappingDefinitionId}/digest&quot;)
    @Consumes({ MediaType.APPLICATION_OCTET_STREAM })
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(summary = &quot;Set ADM Digest&quot;, description = &quot;Save an ADM Digest file on the server&quot;)
    @RequestBody(description = &quot;ADM Digest file content&quot;, content = @Content(schema = @Schema(type = &quot;binary&quot;), mediaType = MediaType.APPLICATION_OCTET_STREAM))
    @ApiResponses({
            @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Succeeded&quot;),
            @ApiResponse(responseCode = &quot;500&quot;, description = &quot;Mapping file save error&quot;) })
    public Response setADMDigestRequest(InputStream mapping,
            @Parameter(description = &quot;Mapping definition ID&quot;) @PathParam(&quot;mappingDefinitionId&quot;) Integer mappingDefinitionId,
            @Context UriInfo uriInfo) {
<span class="fc" id="L459">        LOG.debug(&quot;setADMDigestRequest with definition ID '{}'&quot;, mappingDefinitionId);</span>
<span class="fc" id="L460">        UriBuilder builder = uriInfo.getAbsolutePathBuilder();</span>
<span class="fc" id="L461">        ADMArchiveHandler admHandler = loadExplodedMappingDirectory(mappingDefinitionId);</span>

<span class="fc" id="L463">        LOG.debug(&quot;  setADMDigestRequest '{}' - ID: {}&quot;, admHandler.getGzippedADMDigestFileName(),</span>
                mappingDefinitionId);
        try {
<span class="fc" id="L466">            admHandler.setGzippedADMDigest(mapping);</span>
<span class="fc" id="L467">            admHandler.persist();</span>
<span class="nc" id="L468">        } catch (AtlasException e) {</span>
<span class="nc" id="L469">            LOG.error(&quot;Error saving gzipped ADM digest file.\n&quot; + e.getMessage(), e);</span>
<span class="nc" id="L470">            throw new WebApplicationException(e.getMessage(), e, Status.INTERNAL_SERVER_ERROR);</span>
<span class="fc" id="L471">        }</span>
<span class="fc" id="L472">        builder.path(admHandler.getGzippedADMDigestFileName());</span>
<span class="fc" id="L473">        return Response.ok().location(builder.build()).build();</span>
    }

    /**
    * Retrieve an ADM file saved on the server.
    * @param mappingDefinitionId mapping definition ID
    * @return file
    */
    @GET
    @Path(&quot;/project/{mappingDefinitionId}/adm&quot;)
    @Produces({ MediaType.APPLICATION_OCTET_STREAM })
    @Operation(summary = &quot;Get Mapping&quot;, description = &quot;Retrieve a mapping file saved on the server&quot;)
    @ApiResponses({
            @ApiResponse(responseCode = &quot;200&quot;, content = @Content(schema = @Schema(type = &quot;binary&quot;), mediaType = MediaType.APPLICATION_OCTET_STREAM), description = &quot;Return an ADM file content&quot;),
            @ApiResponse(responseCode = &quot;204&quot;, description = &quot;ADM file was not found&quot;),
            @ApiResponse(responseCode = &quot;500&quot;, description = &quot;ADM file access error&quot;) })
    public Response getADMRequest(
            @Parameter(description = &quot;Mapping ID&quot;) @PathParam(&quot;mappingDefinitionId&quot;) Integer mappingDefinitionId) {
<span class="fc" id="L491">        LOG.debug(&quot;getMappingRequest: {}&quot;, mappingDefinitionId);</span>
<span class="fc" id="L492">        ADMArchiveHandler admHandler = loadExplodedMappingDirectory(mappingDefinitionId);</span>

<span class="fc" id="L494">        try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {</span>
<span class="fc" id="L495">            admHandler.setIgnoreLibrary(false);</span>
<span class="fc" id="L496">            admHandler.setLibraryDirectory(Paths.get(this.libFolder));</span>
<span class="fc" id="L497">            admHandler.export(out);</span>
<span class="fc" id="L498">            return Response.ok().entity(out.toByteArray()).build();</span>
<span class="nc" id="L499">        } catch (Exception e) {</span>
<span class="nc" id="L500">            LOG.error(&quot;Error getting ADM archive file.\n&quot; + e.getMessage(), e);</span>
<span class="nc" id="L501">            throw new WebApplicationException(e.getMessage(), e, Status.INTERNAL_SERVER_ERROR);</span>
        }
    }

    /**
     * Saves an ADM archive file on the server.
     * @param mapping request payload
     * @param mappingDefinitionId mapping definition ID
     * @param uriInfo URI info
     * @return empty response
     */
    @PUT
    @Path(&quot;/project/{mappingDefinitionId}/adm&quot;)
    @Consumes({ MediaType.APPLICATION_OCTET_STREAM })
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(summary = &quot;Import ADM archive&quot;, description = &quot;Import an ADM archive file on the server&quot;)
    @RequestBody(description = &quot;ADM archive file content&quot;, content = @Content(schema = @Schema(type = &quot;binary&quot;), mediaType = MediaType.APPLICATION_OCTET_STREAM))
    @ApiResponses({
            @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Succeeded&quot;),
            @ApiResponse(responseCode = &quot;500&quot;, description = &quot;ADM archive file import error&quot;) })
    public Response importADMArchiveRequest(InputStream mapping,
            @Parameter(description = &quot;Mapping definition ID&quot;) @PathParam(&quot;mappingDefinitionId&quot;) Integer mappingDefinitionId,
            @Context UriInfo uriInfo) {
<span class="fc" id="L524">        LOG.debug(&quot;importADMArchiveRequest with definition ID '{}'&quot;, mappingDefinitionId);</span>
<span class="fc" id="L525">        UriBuilder builder = uriInfo.getAbsolutePathBuilder();</span>
<span class="fc" id="L526">        ADMArchiveHandler admHandler = loadExplodedMappingDirectory(mappingDefinitionId);</span>

<span class="fc" id="L528">        LOG.debug(&quot;  importADMArchiveRequest - ID:'{}'&quot;, mappingDefinitionId);</span>
        try {
<span class="fc" id="L530">            admHandler.setIgnoreLibrary(false);</span>
<span class="fc" id="L531">            admHandler.setLibraryDirectory(Paths.get(libFolder));</span>
<span class="fc" id="L532">            admHandler.load(mapping);</span>
<span class="fc" id="L533">            getLibraryLoader().reload();</span>
<span class="fc" id="L534">            admHandler.persist();</span>
<span class="fc" id="L535">            LOG.debug(&quot;  importADMArchiveRequest complete - ID:'{}'&quot;, mappingDefinitionId);</span>
<span class="nc" id="L536">        } catch (Exception e) {</span>
<span class="nc" id="L537">            LOG.error(&quot;Error importing ADM archive.\n&quot; + e.getMessage(), e);</span>
<span class="nc" id="L538">            throw new WebApplicationException(e.getMessage(), e, Status.INTERNAL_SERVER_ERROR);</span>
<span class="fc" id="L539">        }</span>
<span class="fc" id="L540">        builder.path(&quot;atlasmap-&quot; + mappingDefinitionId + &quot;.adm&quot;);</span>
<span class="fc" id="L541">        return Response.ok().location(builder.build()).build();</span>
    }

    String getMappingSubDirectory(Integer mappingDefinitionId) {
<span class="fc" id="L545">        return this.mappingFolder + File.separator + mappingDefinitionId;</span>
    }

    ADMArchiveHandler loadExplodedMappingDirectory(Integer mappingDefinitionId) {
<span class="fc" id="L549">        java.nio.file.Path mappingDirPath = Paths.get(getMappingSubDirectory(mappingDefinitionId));</span>
<span class="fc" id="L550">        File mappingDirFile = mappingDirPath.toFile();</span>
<span class="fc bfc" id="L551" title="All 2 branches covered.">        if (!mappingDirFile.exists()) {</span>
<span class="fc" id="L552">            mappingDirFile.mkdirs();</span>
        }

<span class="fc" id="L555">        ADMArchiveHandler admHandler = new ADMArchiveHandler(getLibraryLoader());</span>
<span class="fc" id="L556">        admHandler.setIgnoreLibrary(true);</span>
        try {
<span class="fc" id="L558">            admHandler.load(mappingDirPath);</span>
<span class="nc" id="L559">        } catch (Exception e) {</span>
<span class="nc" id="L560">            LOG.error(&quot;Unexpected error while loading mapping directory.\n&quot; + e.getMessage(), e);</span>
<span class="nc" id="L561">            throw new WebApplicationException(e.getMessage(), e, Status.INTERNAL_SERVER_ERROR);</span>
<span class="fc" id="L562">        }</span>
<span class="fc" id="L563">        return admHandler;</span>
    }

    DefaultAtlasContextFactory getContextFactory() {
<span class="fc" id="L567">        return this.atlasContextFactory;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>