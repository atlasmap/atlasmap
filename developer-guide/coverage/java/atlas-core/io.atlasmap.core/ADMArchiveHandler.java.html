<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ADMArchiveHandler.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Unit Test Coverage Report</a> &gt; <a href="../index.html" class="el_bundle">atlas-core</a> &gt; <a href="index.source.html" class="el_package">io.atlasmap.core</a> &gt; <span class="el_source">ADMArchiveHandler.java</span></div><h1>ADMArchiveHandler.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2017 Red Hat, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.atlasmap.core;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Serializable;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.List;
import java.util.Optional;
import java.util.zip.GZIPInputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import java.util.zip.ZipOutputStream;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;

import io.atlasmap.api.AtlasContextFactory;
import io.atlasmap.api.AtlasException;
import io.atlasmap.spi.ReloadableClassLoader;
import io.atlasmap.v2.ADMDigest;
import io.atlasmap.v2.AtlasMapping;
import io.atlasmap.v2.DataSourceMetadata;
import io.atlasmap.v2.DataSourceType;
import io.atlasmap.v2.DocumentCatalog;
import io.atlasmap.v2.DocumentKey;
import io.atlasmap.v2.DocumentMetadata;
import io.atlasmap.v2.DocumentType;
import io.atlasmap.v2.Json;

/**
 * &lt;div&gt;
 * The API for handling ADM archive. It encapsulates ADM archive structure
 * and format and isolate file/stream I/O and serialization/deserializatiopn from other part.
 * ADM archive is a zipped archive file or its exploded directory which contains
 * &lt;ul&gt;
 * &lt;li&gt;Mapping Definition file (atlasmapping-UI.n.json)&lt;/li&gt;
 * &lt;li&gt;Document Catalog file (document-catalog.json&lt;/li&gt;
 * &lt;li&gt;Document specification files (e.g. specification/SOURCE/some-json-doc-id/0)
 * &lt;li&gt;Document inspection result files (e.g. inspected/SOURCE/some-json-doc-id/inspected.json)
 * &lt;li&gt;Java libraries (jar files in lib/ directory)&lt;/li&gt;
 * &lt;/ul&gt;
 * In addition to above, older version of ADM archive has a gzipped digest file {@link ADMDigest}
 * which contains all document metadata and mapping definition in a single JSON file (adm-catalog-files-n.gz).
 * The digest file is deprecated and newer version of AtlasMap converts it into Document catalog
 * file and Document specifications automatically.
 * &lt;/div&gt;
 * {@link #load(Path)} {@link #export(OutputStream)}
 *
 * &lt;div&gt;
 * Note that at this moment Java library directory is not managed by this class.
 * Only when it imports/exports ADM archive file, library jars are extracted/bundled
 * if {@link #isIgnoreLibrary} is set to {@code false}.
 * &lt;/div&gt;
 *
 */
public class ADMArchiveHandler {

<span class="fc" id="L84">    private static final Logger LOG = LoggerFactory.getLogger(ADMArchiveHandler.class);</span>
    private static final String MAPPING_DEFINITION_FILTER = &quot;atlasmapping&quot;;
    private static final String MAPPING_DEFINITION_TEMPLATE = &quot;atlasmapping-UI.%s.json&quot;;
    private static final String GZIPPED_ADM_DIGEST_FILTER = &quot;adm-catalog-files&quot;;
    private static final String DOCUMENT_CATALOG_FILTER = &quot;document-catalog&quot;;
    private static final String DOCUMENT_CATALOG_NAME = &quot;document-catalog.json&quot;;
    private static final String LIB_DIRECTORY = &quot;lib&quot;;
    private static final String SPECIFICATION_DIRECTORY = &quot;specification&quot;;
    private static final String INSPECTED_DIRECTORY = &quot;inspected&quot;;
    private static final String INSPECTED_FILE = &quot;inspected.json&quot;;

    private ObjectMapper jsonMapper;
    private ObjectMapper jsonMapperForDigest;

<span class="fc" id="L98">    private AtlasMapping mappingDefinition = null;</span>
<span class="fc" id="L99">    private AtlasMappingHandler atlasMappingHandler = null;</span>
<span class="fc" id="L100">    private String mappingDefinitionId = &quot;0&quot;;</span>
<span class="fc" id="L101">    private DocumentCatalog documentCatalog = new DocumentCatalog();</span>
<span class="fc" id="L102">    private boolean ignoreLibrary = false;</span>
    private ReloadableClassLoader libraryLoader;
    private Path persistDirectory;
    private Path libraryDirectory;
    
    /**
     * A constructor.
     */
    public ADMArchiveHandler() {
<span class="fc" id="L111">        this(ADMArchiveHandler.class.getClassLoader());</span>
<span class="fc" id="L112">    }</span>

    /**
     * A constructor.
     * @param loader class loader
     */
<span class="fc" id="L118">    public ADMArchiveHandler(ClassLoader loader) {</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">        if (loader instanceof ReloadableClassLoader) {</span>
<span class="fc" id="L120">            this.libraryLoader = (ReloadableClassLoader) loader;</span>
        }
<span class="fc" id="L122">        this.jsonMapper = Json.withClassLoader(loader);</span>
<span class="fc" id="L123">        this.jsonMapperForDigest = this.jsonMapper.copy();</span>
<span class="fc" id="L124">        this.jsonMapperForDigest.configure(DeserializationFeature.UNWRAP_ROOT_VALUE, false);</span>
<span class="fc" id="L125">    }</span>

    /**
     * Load an ADM archive file, an exploded directory or mapping definition JSON file.
     * @param path {@link java.nio.file.Path} of the ADM archive file or an exploded directory
     * @throws AtlasException If it fails to load
     */
    public void load(Path path) throws AtlasException {
<span class="fc" id="L133">        clear();</span>
<span class="fc" id="L134">        File file = path.toFile();</span>
<span class="pc bpc" id="L135" title="2 of 6 branches missed.">        if (!file.exists() || (!file.isFile() &amp;&amp; !file.isDirectory())) {</span>
<span class="nc" id="L136">            throw new AtlasException(</span>
<span class="nc" id="L137">                    String.format(&quot;'%s' doesn't exist or is not a regular file/directory&quot;, path.toString()));</span>
        }

<span class="fc bfc" id="L140" title="All 2 branches covered.">        if (file.isDirectory()) {</span>
<span class="fc" id="L141">            loadExploded(file);</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">        } else if (file.getName().toLowerCase().endsWith(&quot;.adm&quot;)){</span>
<span class="fc" id="L143">            loadADMFile(file);</span>
        } else {
<span class="fc" id="L145">            try (FileInputStream fin = new FileInputStream(file)) {</span>
<span class="fc" id="L146">                setMappingDefinitionFromStream(fin);</span>
<span class="nc" id="L147">            } catch (Exception e) {</span>
<span class="nc" id="L148">                throw new AtlasException(</span>
<span class="nc" id="L149">                        String.format(&quot;Invalid mapping definition file: '%s'&quot;, path.toString()), e);</span>
<span class="fc" id="L150">            }</span>
        }
<span class="fc" id="L152">    }</span>

    /**
     * Load an ADM archive from stream.
     * @param in InputStream to read an ADM Archive
     * @throws AtlasException If it fails to load
     */
    public void load(InputStream in) throws AtlasException {
<span class="fc" id="L160">        load(AtlasContextFactory.Format.ADM, in);</span>
<span class="fc" id="L161">    }</span>

    /**
     * Load an ADM archive or mapping definition from stream.
     * @param format {@code AtlasContextFactory.Format} to indicate stream format
     * @param in InputStream to read an ADM Archive
     * @throws AtlasException If it fails to load
     */
    public void load(AtlasContextFactory.Format format, InputStream in) throws AtlasException {
<span class="fc bfc" id="L170" title="All 2 branches covered.">        if (format == AtlasContextFactory.Format.ADM) {</span>
<span class="fc" id="L171">            loadADMStream(in);</span>
        } else {
            try {
<span class="fc" id="L174">                setMappingDefinitionFromStream(in);</span>
<span class="nc" id="L175">            } catch (Exception e) {</span>
<span class="nc" id="L176">                throw new AtlasException(&quot;Invalid mapping definition from stream&quot;, e);</span>
<span class="fc" id="L177">            }</span>
        }
<span class="fc" id="L179">    }</span>

    /**
     * Export into an ADM archive.
     * @param out OutputStream to write an ADM archive
     * @throws AtlasException If it fails to export
     */
    public void export(OutputStream out) throws AtlasException {
<span class="fc" id="L187">        LOG.debug(&quot;Creating ADM archive file for ID:'{}'&quot;, this.mappingDefinitionId);</span>
<span class="fc" id="L188">        try (ZipOutputStream zipOut = new ZipOutputStream(out)) {</span>
<span class="fc" id="L189">            ZipEntry catEntry = null;</span>

<span class="fc bfc" id="L191" title="All 2 branches covered.">            if (getMappingDefinition() != null) {</span>
<span class="fc" id="L192">                String mappingFileName = getMappingDefinitionFileName();</span>
<span class="fc" id="L193">                LOG.debug(&quot;  Creating mapping definition file '{}'&quot;, mappingFileName);</span>
<span class="fc" id="L194">                catEntry = new ZipEntry(mappingFileName);</span>
<span class="fc" id="L195">                zipOut.putNextEntry(catEntry);</span>
<span class="fc" id="L196">                jsonMapper.writeValue(zipOut, getMappingDefinition());</span>
<span class="fc" id="L197">                zipOut.closeEntry();</span>
            }

<span class="pc bpc" id="L200" title="1 of 2 branches missed.">            if (getDocumentCatalog() != null) {</span>
<span class="fc" id="L201">                LOG.debug(&quot;  Creating Document catalog JSON file '{}'&quot;, DOCUMENT_CATALOG_NAME);</span>
<span class="fc" id="L202">                catEntry = new ZipEntry(DOCUMENT_CATALOG_NAME);</span>
<span class="fc" id="L203">                zipOut.putNextEntry(catEntry);</span>
<span class="fc" id="L204">                byte[] serialized = getSerializedDocumentCatalog();</span>
<span class="fc" id="L205">                zipOut.write(serialized, 0, serialized.length);</span>
<span class="fc" id="L206">                zipOut.closeEntry();</span>
            }

<span class="fc" id="L209">            zipOut.putNextEntry(new ZipEntry(SPECIFICATION_DIRECTORY + &quot;/&quot;));</span>
<span class="fc" id="L210">            zipOut.closeEntry();</span>
<span class="fc" id="L211">            Path specDir = getPersistDirectory().resolve(SPECIFICATION_DIRECTORY);</span>
<span class="fc" id="L212">            Path sourceSpecDir = specDir.resolve(DataSourceType.SOURCE.value());</span>
<span class="fc" id="L213">            String entryPath = SPECIFICATION_DIRECTORY + &quot;/&quot; + DataSourceType.SOURCE.value();</span>
<span class="fc" id="L214">            putDocumentResources(sourceSpecDir, entryPath, zipOut);</span>
<span class="fc" id="L215">            Path targetSpecDir = specDir.resolve(DataSourceType.TARGET.value());</span>
<span class="fc" id="L216">            entryPath = SPECIFICATION_DIRECTORY + &quot;/&quot; + DataSourceType.TARGET.value();</span>
<span class="fc" id="L217">            putDocumentResources(targetSpecDir, entryPath, zipOut);</span>
<span class="fc" id="L218">            zipOut.putNextEntry(new ZipEntry(INSPECTED_DIRECTORY+ &quot;/&quot;));</span>
<span class="fc" id="L219">            zipOut.closeEntry();</span>
<span class="fc" id="L220">            Path inspectedDir = getPersistDirectory().resolve(INSPECTED_DIRECTORY);</span>
<span class="fc" id="L221">            Path sourceInspectedDir = inspectedDir.resolve(DataSourceType.SOURCE.value());</span>
<span class="fc" id="L222">            entryPath = INSPECTED_DIRECTORY + &quot;/&quot; + DataSourceType.SOURCE.value();</span>
<span class="fc" id="L223">            putDocumentResources(sourceInspectedDir, entryPath, zipOut);</span>
<span class="fc" id="L224">            Path targetInspectedDir = inspectedDir.resolve(DataSourceType.TARGET.value());</span>
<span class="fc" id="L225">            entryPath = INSPECTED_DIRECTORY + &quot;/&quot; + DataSourceType.TARGET.value();</span>
<span class="fc" id="L226">            putDocumentResources(targetInspectedDir, entryPath, zipOut);</span>

<span class="pc bpc" id="L228" title="2 of 6 branches missed.">            if (!isIgnoreLibrary() &amp;&amp; libraryDirectory != null &amp;&amp; libraryDirectory.toFile().isDirectory()) {</span>
<span class="fc" id="L229">                zipOut.putNextEntry(new ZipEntry(LIB_DIRECTORY + &quot;/&quot;));</span>
<span class="fc" id="L230">                zipOut.closeEntry();</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">                for (File jarFile : libraryDirectory.toFile().listFiles()) {</span>
<span class="fc" id="L232">                    String path = LIB_DIRECTORY + &quot;/&quot; + jarFile.getName();</span>
<span class="fc" id="L233">                    LOG.debug(&quot;  Creating jar file entry '{}'&quot;, path);</span>
<span class="fc" id="L234">                    ZipEntry libEntry = new ZipEntry(path);</span>
<span class="fc" id="L235">                    zipOut.putNextEntry(libEntry);</span>
<span class="fc" id="L236">                    try (FileInputStream fis = new FileInputStream(jarFile)) {</span>
<span class="fc" id="L237">                        fis.transferTo(zipOut);</span>
                    }
<span class="fc" id="L239">                    zipOut.closeEntry();</span>
                }
            }
<span class="nc" id="L242">        } catch (Exception e) {</span>
<span class="nc" id="L243">            throw new AtlasException(&quot;Error exporting ADM archive file&quot;, e);</span>
<span class="fc" id="L244">        }</span>
<span class="fc" id="L245">    }</span>

    private void putDocumentResources(Path sourceParentPath, String targetParentPath, ZipOutputStream zipOut) throws Exception {
<span class="fc bfc" id="L248" title="All 2 branches covered.">        if (!sourceParentPath.toFile().exists()) {</span>
<span class="fc" id="L249">            return;</span>
        }
<span class="fc bfc" id="L251" title="All 2 branches covered.">        for (File dir : sourceParentPath.toFile().listFiles(f -&gt; f.isDirectory())) {</span>
<span class="fc" id="L252">            Path docDir = sourceParentPath.resolve(dir.getName());</span>
<span class="fc" id="L253">            String docDirEntryPath = targetParentPath + &quot;/&quot; + dir.getName();</span>
<span class="fc" id="L254">            zipOut.putNextEntry(new ZipEntry(docDirEntryPath + &quot;/&quot;));</span>
<span class="fc" id="L255">            zipOut.closeEntry();</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">            for (File f : docDir.toFile().listFiles(f -&gt; f.isFile())) {</span>
<span class="fc" id="L257">                String fileEntryPath = docDirEntryPath + &quot;/&quot; + f.getName();</span>
<span class="fc" id="L258">                LOG.debug(&quot;  Creating file entry '{}'&quot;, fileEntryPath);</span>
<span class="fc" id="L259">                zipOut.putNextEntry(new ZipEntry(fileEntryPath));</span>
<span class="fc" id="L260">                try (FileInputStream fis = new FileInputStream(f)) {</span>
<span class="fc" id="L261">                    fis.transferTo(zipOut);</span>
                }
<span class="fc" id="L263">                zipOut.closeEntry();</span>
            }
        }
<span class="fc" id="L266">    }</span>

    /**
     * Persist ADM archive into a directory.
     * @throws AtlasException If it fails to persist
     */
    public void persist() throws AtlasException {
<span class="fc" id="L273">        Path mdPath = getPersistDirectory().resolve(getMappingDefinitionFileName());</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">        if (getMappingDefinition()  != null) {</span>
            try {
<span class="fc" id="L276">                jsonMapper.writeValue(mdPath.toFile(), getMappingDefinition());</span>
<span class="nc" id="L277">            } catch (Exception e) {</span>
<span class="nc" id="L278">                LOG.warn(&quot;Failed to persist mapping definition&quot;, e);</span>
<span class="fc" id="L279">            }</span>
        }

<span class="fc" id="L282">        Path catalogPath = getPersistDirectory().resolve(DOCUMENT_CATALOG_NAME);</span>
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">        if (getDocumentCatalog() != null) {</span>
            try {
<span class="fc" id="L285">                jsonMapper.writeValue(catalogPath.toFile(), getDocumentCatalog());</span>
<span class="nc" id="L286">            } catch (Exception e) {</span>
<span class="nc" id="L287">                LOG.warn(&quot;Failed to persist Document catalog file&quot;, e);</span>
<span class="fc" id="L288">            }</span>
        }
<span class="fc" id="L290">    }</span>

    /**
     * Gets the {@link AtlasMapping} mapping definition.
     * @return mapping definition
     */
    public AtlasMapping getMappingDefinition() {
<span class="fc" id="L297">        return this.mappingDefinition;</span>
    }

    /**
     * Gets the {@link AtlasMappingHandler}.
     * @return handler
     */
    public AtlasMappingHandler getAtlasMappingHandler() {
<span class="fc" id="L305">        return this.atlasMappingHandler;</span>
    }

    /**
     * Gets the serialized {@link AtlasMapping} in byte array.
     * @return serialized
     */
    public byte[] getSerializedMappingDefinition() throws AtlasException {
<span class="fc bfc" id="L313" title="All 2 branches covered.">        if (getMappingDefinition() == null) {</span>
<span class="fc" id="L314">            return null;</span>
        }
        try {
<span class="fc" id="L317">            ByteArrayOutputStream bos = new ByteArrayOutputStream();</span>
<span class="fc" id="L318">            jsonMapper.writeValue(bos, getMappingDefinition());</span>
<span class="fc" id="L319">            return bos.toByteArray();</span>
<span class="nc" id="L320">        } catch (Exception e) {</span>
<span class="nc" id="L321">            throw new AtlasException(&quot;Failed to serialize mapping definition&quot;, e);</span>
        }
    }

    /**
     * Sets the {@link AtlasMapping} mapping definition.
     * @param mapping mapping definition
     */
    public void setMappingDefinition(AtlasMapping mapping) {
<span class="fc" id="L330">        this.mappingDefinition = mapping;</span>
<span class="fc" id="L331">        this.atlasMappingHandler = new AtlasMappingHandler(mapping);</span>
<span class="fc" id="L332">    }</span>

    /**
     * Sets the serialized mapping definition JSON from InputStream.
     * @param is serialized mapping definition JSON
     * @throws AtlasException unexpected error
     */
    public void setMappingDefinitionFromStream(InputStream is) throws AtlasException {
        try {
<span class="fc" id="L341">            setMappingDefinition(jsonMapper.readValue(is, AtlasMapping.class));</span>
<span class="fc" id="L342">        } catch (Exception e) {</span>
<span class="fc" id="L343">            throw new AtlasException(e);</span>
<span class="fc" id="L344">        }</span>
<span class="fc" id="L345">    }</span>

    /**
     * Looks up the DataSource metadata associated with the specified Document ID.
     * @param dstype DataSourceType to indicate SOURCE or TARGET
     * @param documentId Document ID
     * @return DataSource metadata
     * @throws AtlasException unexpected error
     */
    public DocumentMetadata getDocumentMetadata(DataSourceType dstype, String documentId) throws AtlasException {
<span class="nc" id="L355">        return getDocumentMetadata(new DocumentKey(dstype, documentId));</span>
    }

    /**
     * Looks up the DataSource metadata associated with the specified DataSource key.
     * @param key DataSource key
     * @return DataSource metadata
     * @throws AtlasException unexpected error
     */
    public DocumentMetadata getDocumentMetadata(DocumentKey key) throws AtlasException {
<span class="pc bpc" id="L365" title="1 of 2 branches missed.">        if (getDocumentCatalog() == null) {</span>
<span class="nc" id="L366">            return null;</span>
        }
<span class="fc bfc" id="L368" title="All 2 branches covered.">        List&lt;DocumentMetadata&gt; docs = key.getDataSourceType() == DataSourceType.SOURCE</span>
<span class="fc" id="L369">            ? getDocumentCatalog().getSources()</span>
<span class="fc" id="L370">            : getDocumentCatalog().getTargets();</span>
<span class="fc" id="L371">        Optional&lt;DocumentMetadata&gt; answer = docs.stream().filter(m -&gt; key.getDocumentId().equals(m.getId())).findFirst();</span>
<span class="pc bpc" id="L372" title="1 of 2 branches missed.">        if (answer.isPresent()) {</span>
<span class="fc" id="L373">            return answer.get();</span>
        }
<span class="nc" id="L375">        return null;</span>
    }

    /**
     * Sets the InspectionRequest object as a Document metadata.
     * @param documentKey DocumentKey
     * @param metadata DocumentMetadata
     */
    public void setDocumentMetadata(DocumentKey documentKey, DocumentMetadata metadata) throws AtlasException {
<span class="fc bfc" id="L384" title="All 2 branches covered.">        if (getDocumentCatalog() == null) {</span>
<span class="fc" id="L385">            setDocumentCatalog(new DocumentCatalog());</span>
        }
<span class="fc bfc" id="L387" title="All 2 branches covered.">        List&lt;DocumentMetadata&gt; docs = documentKey.getDataSourceType() == DataSourceType.SOURCE</span>
<span class="fc" id="L388">            ? getDocumentCatalog().getSources()</span>
<span class="fc" id="L389">            : getDocumentCatalog().getTargets();</span>
<span class="fc" id="L390">        Optional&lt;DocumentMetadata&gt; meta = docs.stream().filter(m -&gt; documentKey.getDocumentId().equals(m.getId())).findFirst();</span>
<span class="fc bfc" id="L391" title="All 2 branches covered.">        if (meta.isPresent()) {</span>
<span class="fc" id="L392">            int index = docs.indexOf(meta.get());</span>
<span class="fc" id="L393">            docs.set(index, metadata);</span>
<span class="fc" id="L394">        } else {</span>
<span class="fc" id="L395">            docs.add(metadata);</span>
        }
<span class="fc" id="L397">    }</span>

    /**
     * Sets the DocumentCatalog.
     * @param catalog catalog
     */
    public void setDocumentCatalog(DocumentCatalog catalog) {
<span class="fc" id="L404">        this.documentCatalog = catalog;</span>
<span class="fc" id="L405">    }</span>

    /**
     * Gets a map of Document metadata.
     * @return a map of Document metadata.
     * @throws AtlasException unexpected error
     */
    public DocumentCatalog getDocumentCatalog() throws AtlasException {
<span class="fc" id="L413">        return this.documentCatalog;</span>
    }

    /**
     * Serializes the {@link DocumentCatalog} into JSON and return as a byte array.
     * @return serialized {@link DocumentCatalog}
     * @throws AtlasException unexpected error
     */
    public byte[] getSerializedDocumentCatalog() throws AtlasException {
<span class="pc bpc" id="L422" title="1 of 2 branches missed.">        if (getDocumentCatalog() == null) {</span>
<span class="nc" id="L423">            return null;</span>
        }
        try {
<span class="fc" id="L426">            ByteArrayOutputStream bos = new ByteArrayOutputStream();</span>
<span class="fc" id="L427">            jsonMapper.writeValue(bos, getDocumentCatalog());</span>
<span class="fc" id="L428">            return bos.toByteArray();</span>
<span class="nc" id="L429">        } catch (Exception e) {</span>
<span class="nc" id="L430">            throw new AtlasException(&quot;Failed to serialize Document catalog&quot;, e);</span>
        }
    }

    /**
     * Sets a map of Document metadata from InputStream.
     * @param is Document catalog InputStream
     * @throws AtlasException unexpected error
     */
    public void setDocumentCatalogFromStream(InputStream is) throws AtlasException {
        try {
<span class="fc" id="L441">            this.documentCatalog = jsonMapper.readValue(is, DocumentCatalog.class);</span>
<span class="nc" id="L442">        } catch (Exception e) {</span>
<span class="nc" id="L443">            throw new AtlasException(e);</span>
<span class="fc" id="L444">        }</span>
<span class="fc" id="L445">    }</span>

    /**
     * Clones a {@link AtlasMapping} mapping definition object.
     * @return mapping definition
     * @throws AtlasException unexpected error
     */
    public AtlasMapping cloneMappingDefinition() throws AtlasException {
<span class="fc" id="L453">        AtlasMapping atlasMapping = getMappingDefinition();</span>
<span class="pc bpc" id="L454" title="1 of 2 branches missed.">        if (atlasMapping == null) {</span>
<span class="nc" id="L455">            return null;</span>
        }
        try {
<span class="fc" id="L458">            byte[] bytes = this.jsonMapper.writeValueAsBytes(atlasMapping);</span>
<span class="fc" id="L459">            return this.jsonMapper.readValue(bytes, AtlasMapping.class);</span>
<span class="nc" id="L460">        } catch (Exception e) {</span>
<span class="nc" id="L461">            throw new AtlasException(e);</span>
        }
    }

    /**
     * Clears all contents.
     */
    public void clear() throws AtlasException {
<span class="fc" id="L469">        this.mappingDefinition = null;</span>
<span class="fc" id="L470">        this.atlasMappingHandler = null;</span>
<span class="fc" id="L471">        this.documentCatalog = null;</span>
<span class="fc bfc" id="L472" title="All 2 branches covered.">        if (getPersistDirectory().resolve(SPECIFICATION_DIRECTORY).toFile().exists()) {</span>
<span class="fc bfc" id="L473" title="All 2 branches covered.">            for (File f : getPersistDirectory().resolve(SPECIFICATION_DIRECTORY).toFile().listFiles()) {</span>
<span class="fc" id="L474">                AtlasUtil.deleteDirectory(f);</span>
            }
            
        }
<span class="fc bfc" id="L478" title="All 2 branches covered.">        if (getPersistDirectory().resolve(INSPECTED_DIRECTORY).toFile().exists()) {</span>
<span class="fc bfc" id="L479" title="All 2 branches covered.">            for (File f : getPersistDirectory().resolve(INSPECTED_DIRECTORY).toFile().listFiles()) {</span>
<span class="fc" id="L480">                AtlasUtil.deleteDirectory(f);</span>
            }
            
        }
<span class="fc bfc" id="L484" title="All 2 branches covered.">        if (getPersistDirectory().resolve(getMappingDefinitionFileName()).toFile().exists()) {</span>
<span class="fc" id="L485">            getPersistDirectory().resolve(getMappingDefinitionFileName()).toFile().delete();</span>
        }
<span class="pc bpc" id="L487" title="1 of 2 branches missed.">        if (getPersistDirectory().resolve(DOCUMENT_CATALOG_NAME).toFile().exists()) {</span>
<span class="nc" id="L488">            getPersistDirectory().resolve(DOCUMENT_CATALOG_NAME).toFile().delete();</span>
        }
<span class="fc" id="L490">    }</span>

    /**
     * Sets if it ignores the library or not.
     * @param ignoreLib true to ignore library, or false
     */
    public void setIgnoreLibrary(boolean ignoreLib) {
<span class="fc" id="L497">        this.ignoreLibrary = ignoreLib;</span>
<span class="fc" id="L498">    }</span>

    /**
     * Gets if it ignores the library or not.
     * @return true if it ignores library, or false
     */
    public boolean isIgnoreLibrary() {
<span class="fc" id="L505">        return this.ignoreLibrary;</span>
    }

    /**
     * Sets the persistent directory.
     * @param dir persistent directory path
     * @throws AtlasException unexpected error
     */
    public void setPersistDirectory(Path dir) throws AtlasException {
<span class="fc" id="L514">        ensureDirectory(dir);</span>
<span class="fc" id="L515">        this.persistDirectory = dir;</span>
<span class="fc" id="L516">    }</span>

    /**
     * Gets the persistent directory.
     * @return persistent directory path
     * @throws AtlasException unexpected error
     */
    public Path getPersistDirectory() throws AtlasException {
<span class="fc bfc" id="L524" title="All 2 branches covered.">        if (this.persistDirectory == null) {</span>
            try {
<span class="fc" id="L526">                this.persistDirectory = Files.createTempDirectory(&quot;atlasmap&quot;);</span>
<span class="fc" id="L527">                this.persistDirectory.toFile().deleteOnExit();</span>
<span class="nc" id="L528">            } catch (IOException e) {</span>
<span class="nc" id="L529">                throw new AtlasException(&quot;Failed to create a temporary directory to extract the ADM file&quot;, e);</span>
<span class="fc" id="L530">            }</span>
        }
<span class="fc" id="L532">        return this.persistDirectory;</span>
    }

    /**
     * Sets the library directory.
     * @param dir library directory path
     * @throws AtlasException unexpected error
     */
    public void setLibraryDirectory(Path dir) throws AtlasException {
<span class="fc" id="L541">        ensureDirectory(dir);</span>
<span class="fc" id="L542">        this.libraryDirectory = dir;</span>
<span class="fc" id="L543">    }</span>

    /**
     * Sets the mapping definition ID.
     * @param id mapping definition ID
     */
    public void setMappingDefinitionId(String id) {
<span class="fc" id="L550">        this.mappingDefinitionId = id;</span>
<span class="fc" id="L551">    }</span>

    /**
     * Gets the file name of the mapping definition JSON.
     * @return file name
     */
    public String getMappingDefinitionFileName() {
<span class="fc" id="L558">        return String.format(MAPPING_DEFINITION_TEMPLATE, this.mappingDefinitionId);</span>
    }

    /**
     * Sets the Document specification.
     * @param documentKey DocumentKey
     * @param name file name
     * @param specification Document specification
     */
    public void setDocumentSpecification(DocumentKey documentKey, String name, InputStream specification) throws AtlasException {
<span class="fc" id="L568">        Path dsTypePath = getPersistDirectory().resolve(SPECIFICATION_DIRECTORY).resolve(documentKey.getDataSourceType().value());</span>
<span class="fc" id="L569">        ensureDirectory(dsTypePath);</span>
<span class="fc" id="L570">        Path docPath = dsTypePath.resolve(documentKey.getDocumentId());</span>
<span class="fc" id="L571">        AtlasUtil.deleteDirectory(docPath.toFile());</span>
<span class="fc" id="L572">        ensureDirectory(docPath);</span>
<span class="fc" id="L573">        Path filePath = docPath.resolve(name);</span>
<span class="fc" id="L574">        try (FileOutputStream fos = new FileOutputStream(filePath.toFile(), false)) {</span>
<span class="fc" id="L575">            specification.transferTo(fos);</span>
<span class="nc" id="L576">        } catch (Exception e) {</span>
<span class="nc" id="L577">            LOG.warn(String.format(&quot;Failed to save a specification file '%s', ignoring...&quot;, filePath.toString()), e);</span>
<span class="fc" id="L578">        }</span>
<span class="fc" id="L579">    }</span>

    /**
     * Sets the Document specification.
     * @param documentKey DocumentKey
     * @param specification Document specification
     */
    public void setDocumentSpecification(DocumentKey documentKey, InputStream specification) throws AtlasException {
<span class="fc" id="L587">        setDocumentSpecification(documentKey, &quot;0&quot;, specification);</span>
<span class="fc" id="L588">    }</span>

    /**
     * Sets the Document specification.
     * @param dsType DataSourceType indicating SOURCE or TARGET
     * @param docId Document ID
     * @param in input stream
     * @throws AtlasException
     */
    public void setDocumentSpecificationFile(String dsType, String docId, InputStream in) throws AtlasException {
<span class="fc" id="L598">        setDocumentSpecification(new DocumentKey(DataSourceType.fromValue(dsType), docId), in);</span>
<span class="fc" id="L599">    }</span>

    /**
     * Gets the Document specification file handler.
     * @param docKey DocumentKey
     * @return file handler
     */
    public File getDocumentSpecificationFile(DocumentKey docKey) throws AtlasException {
<span class="fc" id="L607">        File specDir = getDocumentSpecificationDirectory(docKey);</span>
<span class="pc bpc" id="L608" title="2 of 6 branches missed.">        if (!specDir.exists() || !specDir.isDirectory() || specDir.list().length != 1) {</span>
<span class="fc" id="L609">            return null;</span>
        }
<span class="fc" id="L611">        return specDir.listFiles()[0];</span>
    }
  
    private File getDocumentSpecificationDirectory(DocumentKey docKey) throws AtlasException {
<span class="fc" id="L615">        return getPersistDirectory()</span>
<span class="fc" id="L616">            .resolve(SPECIFICATION_DIRECTORY)</span>
<span class="fc" id="L617">            .resolve(docKey.getDataSourceType().value())</span>
<span class="fc" id="L618">            .resolve(docKey.getDocumentId())</span>
<span class="fc" id="L619">            .toFile();</span>
    }

    /**
     * Sets the Document inspection result.
     * @param documentKey DocumentKey
     * @param resultObject Document inspection result object
     * @throws AtlasException unexpected error
     */
    public void setDocumentInspectionResult(DocumentKey documentKey, Serializable resultObject) throws AtlasException {
<span class="fc" id="L629">        Path docPath = getPersistDirectory()</span>
<span class="fc" id="L630">            .resolve(INSPECTED_DIRECTORY)</span>
<span class="fc" id="L631">            .resolve(documentKey.getDataSourceType().value())</span>
<span class="fc" id="L632">            .resolve(documentKey.getDocumentId());</span>
<span class="fc" id="L633">        AtlasUtil.deleteDirectory(docPath.toFile());</span>
<span class="fc" id="L634">        ensureDirectory(docPath);</span>
<span class="fc" id="L635">        Path filePath = docPath.resolve(INSPECTED_FILE);</span>
<span class="fc" id="L636">        try (FileOutputStream fos = new FileOutputStream(filePath.toFile(), false)) {</span>
<span class="fc" id="L637">            jsonMapper.writeValue(fos, resultObject);</span>
<span class="nc" id="L638">        } catch (Exception e) {</span>
<span class="nc" id="L639">            LOG.warn(String.format(&quot;Failed to save an inspection result JSON file '%s', ignoring...&quot;, filePath.toString()), e);</span>
<span class="fc" id="L640">        }</span>
<span class="fc" id="L641">    }</span>

    /**
     * Store the serialized Document inspection result into a file.
     * @param dsType DataSourceType
     * @param docId Document ID
     * @param in serialized Document inspection result
     * @throws AtlasException unexpected error
     */
    public void setDocumentInspectionResultFile(String dsType, String docId, InputStream in) throws AtlasException {
<span class="fc" id="L651">        setDocumentInspectionResultFile(new DocumentKey(DataSourceType.fromValue(dsType), docId), in);</span>
<span class="fc" id="L652">    }</span>

    /**
     * Store the serialized Document inspection result into a file.
     * @param documentKey DocumentKey to identify the Document
     * @param in serialized Document inspection result
     * @throws AtlasException unexpected error
     */
    public void setDocumentInspectionResultFile(DocumentKey documentKey, InputStream in) throws AtlasException {
<span class="fc" id="L661">        Path docPath = getPersistDirectory()</span>
<span class="fc" id="L662">            .resolve(INSPECTED_DIRECTORY)</span>
<span class="fc" id="L663">            .resolve(documentKey.getDataSourceType().value())</span>
<span class="fc" id="L664">            .resolve(documentKey.getDocumentId());</span>
<span class="fc" id="L665">        ensureDirectory(docPath);</span>
<span class="fc" id="L666">        Path filePath = docPath.resolve(INSPECTED_FILE);</span>
<span class="fc" id="L667">        try (FileOutputStream fos = new FileOutputStream(filePath.toFile(), false)) {</span>
<span class="fc" id="L668">            in.transferTo(fos);</span>
<span class="nc" id="L669">        } catch (Exception e) {</span>
<span class="nc" id="L670">            LOG.warn(String.format(&quot;Failed to save an inspection result JSON file '%s', ignoring...&quot;, filePath.toString()), e);</span>
<span class="fc" id="L671">        }</span>
<span class="fc" id="L672">    }</span>

    /**
     * Gets the {@link File} which represents the persisted Document inspection result file.
     * @param documentKey DocumentKey to identify the Document
     * @return {@link File} for the persisted Document inspection result file
     * @throws AtlasException unexpected error
     */
    public File getDocumentInspectionResultFile(DocumentKey documentKey) throws AtlasException {
<span class="fc" id="L681">        File inspectedDir = getDocumentInspectionResultDirectory(documentKey);</span>
<span class="pc bpc" id="L682" title="2 of 6 branches missed.">        if (!inspectedDir.exists() || !inspectedDir.isDirectory() || inspectedDir.list().length != 1) {</span>
<span class="fc" id="L683">            return null;</span>
        }
<span class="fc" id="L685">        return inspectedDir.listFiles()[0];</span>
    }

    private File getDocumentInspectionResultDirectory(DocumentKey documentKey) throws AtlasException {
<span class="fc" id="L689">        return getPersistDirectory()</span>
<span class="fc" id="L690">            .resolve(INSPECTED_DIRECTORY)</span>
<span class="fc" id="L691">            .resolve(documentKey.getDataSourceType().value())</span>
<span class="fc" id="L692">            .resolve(documentKey.getDocumentId())</span>
<span class="fc" id="L693">            .toFile();</span>
    }

    /**
     * Deletes the Document specification, inspection result and metadata from the {@link DocumentCatalog}.
     * This also invokes {@link AtlasMappingHandler#removeDocumentReference(DocumentKey)} to remove
     * all the Document references from the Mapping Definition.
     * @param dsType SOURCE or TARGET
     * @param documentId Document ID of the Document to be deleted
     */
    public void deleteDocument(DataSourceType dsType, String documentId) throws AtlasException {
<span class="fc" id="L704">        DocumentCatalog catalog = getDocumentCatalog();</span>
<span class="pc bpc" id="L705" title="1 of 2 branches missed.">        List&lt;DocumentMetadata&gt; docs = dsType == DataSourceType.SOURCE ? catalog.getSources() : catalog.getTargets();</span>
<span class="fc" id="L706">        Optional&lt;DocumentMetadata&gt; todelete = docs.stream().filter(m -&gt; m.getId().equals(documentId)).findAny();</span>
<span class="pc bpc" id="L707" title="1 of 2 branches missed.">        if (!todelete.isPresent()) {</span>
<span class="nc" id="L708">            return;</span>
        }
<span class="fc" id="L710">        docs.remove(todelete.get());</span>
<span class="fc" id="L711">        DocumentKey docKey = new DocumentKey(dsType, documentId);</span>
<span class="fc" id="L712">        File specDir = getDocumentSpecificationDirectory(docKey);</span>
<span class="pc bpc" id="L713" title="2 of 4 branches missed.">        if (specDir != null &amp;&amp; specDir.exists()) {</span>
<span class="fc" id="L714">            AtlasUtil.deleteDirectory(specDir);</span>
        }
<span class="fc" id="L716">        File inspectedDir = getDocumentInspectionResultDirectory(docKey);</span>
<span class="pc bpc" id="L717" title="2 of 4 branches missed.">        if (inspectedDir != null &amp;&amp; specDir.exists()) {</span>
<span class="nc" id="L718">            AtlasUtil.deleteDirectory(inspectedDir);</span>
        }
<span class="fc" id="L720">        getAtlasMappingHandler().removeDocumentReference(docKey);</span>
<span class="fc" id="L721">    }</span>

    /**
     * Loads ADM Archive from an exploded directory.
     * @param dir directory path.
     * @throws AtlasException unexpected error
     */
    private void loadExploded(File dir) throws AtlasException {
<span class="fc" id="L729">        setPersistDirectory(dir.toPath());</span>
<span class="fc" id="L730">        this.mappingDefinitionId = dir.getName();</span>
<span class="fc" id="L731">        File mappingDefinitionFile = dir.toPath().resolve(getMappingDefinitionFileName()).toFile();</span>
<span class="pc bpc" id="L732" title="1 of 4 branches missed.">        if (mappingDefinitionFile.exists() &amp;&amp; mappingDefinitionFile.isFile()) {</span>
<span class="fc" id="L733">            try (InputStream mappingdefis = new FileInputStream(mappingDefinitionFile)) {</span>
<span class="fc" id="L734">                setMappingDefinitionFromStream(mappingdefis);</span>
<span class="nc" id="L735">            } catch (Exception e) {</span>
<span class="nc" id="L736">                throw new AtlasException(&quot;Failed to read mapping definition file&quot;, e);</span>
<span class="fc" id="L737">            }</span>
        }

<span class="fc" id="L740">        File catalogFile = dir.toPath().resolve(DOCUMENT_CATALOG_NAME).toFile();</span>
<span class="pc bpc" id="L741" title="1 of 4 branches missed.">        if (catalogFile.exists() &amp;&amp; catalogFile.isFile()) {</span>
<span class="fc" id="L742">            try (InputStream catalogis = new FileInputStream(catalogFile)) {</span>
<span class="fc" id="L743">                setDocumentCatalogFromStream(catalogis);</span>
<span class="nc" id="L744">            } catch (Exception e) {</span>
<span class="nc" id="L745">                throw new AtlasException(&quot;Failed to read document catalog file&quot;, e);</span>
<span class="fc" id="L746">            }</span>
        }
<span class="fc" id="L748">    }</span>

    private void loadADMFile(File file) throws AtlasException {
<span class="fc" id="L751">        try (FileInputStream fis = new FileInputStream(file)) {</span>
<span class="fc" id="L752">            loadADMStream(fis);</span>
<span class="nc" id="L753">        } catch (AtlasException ae) {</span>
<span class="nc" id="L754">            throw ae;</span>
<span class="nc" id="L755">        } catch (Exception e) {</span>
<span class="nc" id="L756">            throw new AtlasException(e);</span>
<span class="fc" id="L757">        }</span>
<span class="fc" id="L758">    }</span>

    private void loadADMStream(InputStream in) throws AtlasException {
        String catEntryName;
        ZipEntry catEntry;
<span class="fc" id="L763">        try (ZipInputStream zipIn = new ZipInputStream(in)) {</span>
<span class="fc" id="L764">            boolean mappingDefinitionFound = false;</span>
<span class="fc" id="L765">            boolean libraryFound = false;</span>
<span class="fc bfc" id="L766" title="All 2 branches covered.">            while ((catEntry = zipIn.getNextEntry()) != null) {</span>
<span class="fc bfc" id="L767" title="All 2 branches covered.">                if (catEntry.isDirectory()) {</span>
<span class="fc" id="L768">                    continue;</span>
                }
<span class="fc" id="L770">                catEntryName = cleanSeparator(catEntry.getName());</span>
<span class="fc" id="L771">                LOG.debug(&quot;  Extracting ADM file entry '{}'&quot;, catEntryName);</span>
<span class="fc bfc" id="L772" title="All 2 branches covered.">                if (catEntryName.contains(GZIPPED_ADM_DIGEST_FILTER)) {</span>
<span class="fc" id="L773">                    extractFromGzippedADMDigest(zipIn);</span>
<span class="fc bfc" id="L774" title="All 2 branches covered.">                } else if (catEntryName.contains(DOCUMENT_CATALOG_FILTER)) {</span>
<span class="fc" id="L775">                    setDocumentCatalogFromStream(zipIn);</span>
<span class="fc bfc" id="L776" title="All 2 branches covered.">                } else if (catEntryName.startsWith(SPECIFICATION_DIRECTORY)) {</span>
<span class="fc" id="L777">                    String[] segments = catEntryName.split(&quot;/&quot;);</span>
<span class="pc bpc" id="L778" title="1 of 2 branches missed.">                    if (segments.length != 4) {</span>
<span class="nc" id="L779">                        continue;</span>
                    }
<span class="fc" id="L781">                    setDocumentSpecificationFile(segments[1], segments[2], zipIn);</span>
<span class="fc bfc" id="L782" title="All 2 branches covered.">                } else if (catEntryName.startsWith(INSPECTED_DIRECTORY)) {</span>
<span class="fc" id="L783">                    String[] segments = catEntryName.split(&quot;/&quot;);</span>
<span class="pc bpc" id="L784" title="1 of 2 branches missed.">                    if (segments.length != 4) {</span>
<span class="nc" id="L785">                        continue;</span>
                    }
<span class="fc" id="L787">                    setDocumentInspectionResultFile(segments[1], segments[2], zipIn);</span>
<span class="fc bfc" id="L788" title="All 4 branches covered.">                } else if (!isIgnoreLibrary() &amp;&amp; catEntryName.contains(&quot;.jar&quot;)) {</span>
<span class="pc bpc" id="L789" title="1 of 2 branches missed.">                    if (this.libraryDirectory == null) {</span>
<span class="nc" id="L790">                        throw new AtlasException(&quot;Library directory is not specified&quot;);</span>
                    }
<span class="fc" id="L792">                    int separatorPos = catEntryName.lastIndexOf(&quot;/&quot;);</span>
<span class="pc bpc" id="L793" title="1 of 2 branches missed.">                    String name = separatorPos == -1 ? catEntryName : catEntryName.substring(separatorPos + 1);</span>
<span class="fc" id="L794">                    Path libPath = this.libraryDirectory.resolve(name);</span>
<span class="fc" id="L795">                    try (FileOutputStream fos = new FileOutputStream(libPath.toFile(), false)) {</span>
<span class="fc" id="L796">                        zipIn.transferTo(fos);</span>
<span class="fc" id="L797">                        libraryFound = true;</span>
<span class="nc" id="L798">                    } catch (Exception e) {</span>
<span class="nc" id="L799">                        LOG.warn(String.format(&quot;Failed to save a jar file '%s', ignoring...&quot;, name), e);</span>
<span class="fc" id="L800">                    }</span>
<span class="fc bfc" id="L801" title="All 2 branches covered.">                } else if (catEntryName.contains(MAPPING_DEFINITION_FILTER)) {</span>
<span class="pc bpc" id="L802" title="1 of 2 branches missed.">                    if (mappingDefinitionFound) {</span>
<span class="nc" id="L803">                        throw new AtlasException(&quot;Multiple mapping definition files are found in a same .adm archive&quot;);</span>
                    }
<span class="fc" id="L805">                    ensureDirectory(getPersistDirectory());</span>
<span class="fc" id="L806">                    Path mdPath = getPersistDirectory().resolve(getMappingDefinitionFileName());</span>
<span class="fc" id="L807">                    zipIn.transferTo(new FileOutputStream(mdPath.toFile()));</span>
<span class="fc" id="L808">                    mappingDefinitionFound = true;</span>
<span class="fc" id="L809">                } else {</span>
<span class="fc" id="L810">                    LOG.debug(&quot;Ignoring file '{}' in .adm archive&quot;, catEntryName);</span>
                }
            }
<span class="fc bfc" id="L813" title="All 4 branches covered.">            if (libraryFound &amp;&amp; this.libraryLoader != null) {</span>
<span class="fc" id="L814">                this.libraryLoader.reload();</span>
            }
            // MappingDefinition potentially needs the custom Java classes to be loaded to deserialize
<span class="fc bfc" id="L817" title="All 2 branches covered.">            if (mappingDefinitionFound) {</span>
<span class="fc" id="L818">                Path mdPath = getPersistDirectory().resolve(getMappingDefinitionFileName());</span>
<span class="fc" id="L819">                setMappingDefinitionFromStream(new FileInputStream(mdPath.toFile()));</span>
            }
<span class="nc" id="L821">        } catch (Exception e) {</span>
<span class="nc" id="L822">            throw new AtlasException(e);</span>
<span class="fc" id="L823">        }</span>
<span class="fc" id="L824">    }</span>

    private String cleanSeparator(String path) {
<span class="pc bpc" id="L827" title="1 of 2 branches missed.">        return path != null ? path.replaceAll(&quot;\\\\&quot;, &quot;/&quot;) : null;</span>
    }

    /**
     * Extracts Document metadata and specification from gzipped ADMDigest. It will be converted to
     * the DocumentCatalog and individual specification/inspected files.
     * @param in gzipped ADMDigest JSON file
     * @deprecated {@link ADMDigest} is kept for backward compatibility. It is recommended to convert the ADM
     * file with the newer version of AtlasMap UI to avoid auto conversion happens everytime the ADM file is loaded.
     */
    @Deprecated
    private void extractFromGzippedADMDigest(InputStream in) throws AtlasException {
        try {
<span class="fc" id="L840">            GZIPInputStream gzipped = new GZIPInputStream(in);</span>
<span class="fc" id="L841">            ADMDigest digest = jsonMapperForDigest.readValue(gzipped, ADMDigest.class);</span>
<span class="fc" id="L842">            setDocumentCatalog(new DocumentCatalog());</span>
<span class="fc bfc" id="L843" title="All 2 branches covered.">            for (int i=0; i&lt;digest.getExportMeta().length; i++) {</span>
<span class="fc" id="L844">                DataSourceMetadata meta = digest.getExportMeta()[i];</span>
<span class="fc" id="L845">                String spec = digest.getExportBlockData()[i].getValue();</span>
<span class="fc bfc" id="L846" title="All 2 branches covered.">                if (meta.getId() == null) {</span>
<span class="fc" id="L847">                    meta.setId(meta.getName());</span>
                }
<span class="fc" id="L849">                DocumentMetadata docMeta = createDocumentMetadataFrom(meta);</span>
<span class="fc" id="L850">                DocumentKey docKey = new DocumentKey(docMeta.getDataSourceType(), meta.getId());</span>
<span class="fc" id="L851">                setDocumentMetadata(docKey, docMeta);</span>
<span class="pc bpc" id="L852" title="1 of 2 branches missed.">                if (spec != null) {</span>
<span class="fc" id="L853">                    setDocumentSpecification(docKey, new ByteArrayInputStream(spec.getBytes()));</span>
                }
            }
<span class="nc" id="L856">        } catch (Exception e) {</span>
<span class="nc" id="L857">            throw new AtlasException(e);</span>
<span class="fc" id="L858">        }</span>
<span class="fc" id="L859">    }</span>

    private DocumentMetadata createDocumentMetadataFrom(DataSourceMetadata meta) {
<span class="fc" id="L862">        DocumentMetadata answer = new DocumentMetadata();</span>
<span class="fc" id="L863">        answer.setId(meta.getId());</span>
<span class="fc" id="L864">        answer.setName(meta.getName());</span>
<span class="fc" id="L865">        String docTypeStr = meta.getDocumentType();</span>
<span class="fc bfc" id="L866" title="All 2 branches covered.">        if (docTypeStr != null) {</span>
<span class="fc" id="L867">            answer.setDocumentType(DocumentType.fromValue(docTypeStr.toUpperCase()));</span>
        } else {
            // old adm file has DocumentType as DataSourceType
<span class="fc" id="L870">            docTypeStr = meta.getDataSourceType();</span>
<span class="pc bpc" id="L871" title="1 of 2 branches missed.">            if (docTypeStr != null) {</span>
                try {
<span class="fc" id="L873">                    answer.setDocumentType(DocumentType.fromValue(docTypeStr.toUpperCase()));</span>
<span class="pc" id="L874">                } catch (IllegalArgumentException e) {}</span>
            }
        }
<span class="fc" id="L877">        answer.setInspectionType(meta.getInspectionType());</span>
<span class="fc bfc" id="L878" title="All 2 branches covered.">        answer.setDataSourceType(meta.getIsSource() ? DataSourceType.SOURCE : DataSourceType.TARGET);</span>
<span class="fc" id="L879">        answer.setInspectionParameters(meta.getInspectionParameters());</span>
<span class="fc bfc" id="L880" title="All 2 branches covered.">        if (answer.getDocumentType() == DocumentType.JAVA) {</span>
<span class="fc bfc" id="L881" title="All 2 branches covered.">            if (answer.getInspectionParameters() == null) {</span>
<span class="fc" id="L882">                answer.setInspectionParameters(new HashMap&lt;&gt;());</span>
            }
<span class="pc bpc" id="L884" title="1 of 2 branches missed.">            if (!answer.getInspectionParameters().containsKey(&quot;className&quot;)) {</span>
                // old adm file has the FQCN of the Java Document only as a Document ID
<span class="fc" id="L886">                answer.getInspectionParameters().put(&quot;className&quot;, answer.getId());</span>
            }
        }
<span class="fc" id="L889">        return answer;</span>
    }

    private boolean ensureDirectory(Path dir) throws AtlasException {
<span class="pc bpc" id="L893" title="1 of 2 branches missed.">        if (dir == null) {</span>
<span class="nc" id="L894">            throw new AtlasException(String.format(&quot;Directory must not be Null&quot;));</span>
        }
<span class="fc" id="L896">        File dirf = dir.toFile();</span>
<span class="pc bpc" id="L897" title="1 of 4 branches missed.">        if (dirf.exists() &amp;&amp; !dirf.isDirectory()) {</span>
<span class="nc" id="L898">            throw new AtlasException(String.format(&quot;File '%s' is not a directory&quot;, dirf.getAbsolutePath()));</span>
<span class="fc bfc" id="L899" title="All 2 branches covered.">        } else if (!dirf.exists()) {</span>
<span class="fc" id="L900">            dirf.mkdirs();</span>
        }

<span class="fc" id="L903">        return true;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>