<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ADMArchiveHandler.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Unit Test Coverage Report</a> &gt; <a href="../index.html" class="el_bundle">atlas-core</a> &gt; <a href="index.source.html" class="el_package">io.atlasmap.core</a> &gt; <span class="el_source">ADMArchiveHandler.java</span></div><h1>ADMArchiveHandler.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2017 Red Hat, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.atlasmap.core;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Serializable;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.List;
import java.util.Optional;
import java.util.zip.GZIPInputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import java.util.zip.ZipOutputStream;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;

import io.atlasmap.api.AtlasContextFactory;
import io.atlasmap.api.AtlasException;
import io.atlasmap.spi.ReloadableClassLoader;
import io.atlasmap.v2.ADMDigest;
import io.atlasmap.v2.AtlasMapping;
import io.atlasmap.v2.DataSourceMetadata;
import io.atlasmap.v2.DataSourceType;
import io.atlasmap.v2.DocumentCatalog;
import io.atlasmap.v2.DocumentKey;
import io.atlasmap.v2.DocumentMetadata;
import io.atlasmap.v2.DocumentType;
import io.atlasmap.v2.Json;

/**
 * &lt;div&gt;
 * The API for handling ADM archive. It encapsulates ADM archive structure
 * and format and isolate file/stream I/O and serialization/deserializatiopn from other part.
 * ADM archive is a zipped archive file or its exploded directory which contains
 * &lt;ul&gt;
 * &lt;li&gt;Mapping Definition file (atlasmapping-UI.n.json)&lt;/li&gt;
 * &lt;li&gt;Document Catalog file (document-catalog.json&lt;/li&gt;
 * &lt;li&gt;Document specification files (e.g. specification/SOURCE/some-json-doc-id/0)
 * &lt;li&gt;Document inspection result files (e.g. inspected/SOURCE/some-json-doc-id/inspected.json)
 * &lt;li&gt;Java libraries (jar files in lib/ directory)&lt;/li&gt;
 * &lt;/ul&gt;
 * In addition to above, older version of ADM archive has a gzipped digest file {@link ADMDigest}
 * which contains all document metadata and mapping definition in a single JSON file (adm-catalog-files-n.gz).
 * The digest file is deprecated and newer version of AtlasMap converts it into Document catalog
 * file and Document specifications automatically.
 * &lt;/div&gt;
 * {@link #load(Path)} {@link #export(OutputStream)}
 *
 * &lt;div&gt;
 * Note that at this moment Java library directory is not managed by this class.
 * Only when it imports/exports ADM archive file, library jars are extracted/bundled
 * if {@link #isIgnoreLibrary} is set to {@code false}.
 * &lt;/div&gt;
 *
 */
public class ADMArchiveHandler {

<span class="fc" id="L84">    private static final Logger LOG = LoggerFactory.getLogger(ADMArchiveHandler.class);</span>
    private static final String MAPPING_DEFINITION_FILTER = &quot;atlasmapping&quot;;
    private static final String MAPPING_DEFINITION_TEMPLATE = &quot;atlasmapping-UI.%s.json&quot;;
    private static final String GZIPPED_ADM_DIGEST_FILTER = &quot;adm-catalog-files&quot;;
    private static final String DOCUMENT_CATALOG_FILTER = &quot;document-catalog&quot;;
    private static final String DOCUMENT_CATALOG_NAME = &quot;document-catalog.json&quot;;
    private static final String LIB_DIRECTORY = &quot;lib&quot;;
    private static final String SPECIFICATION_DIRECTORY = &quot;specification&quot;;
    private static final String INSPECTED_DIRECTORY = &quot;inspected&quot;;
    private static final String INSPECTED_FILE = &quot;inspected.json&quot;;

    private ObjectMapper jsonMapper;
    private ObjectMapper jsonMapperForDigest;

<span class="fc" id="L98">    private AtlasMapping mappingDefinition = null;</span>
<span class="fc" id="L99">    private AtlasMappingHandler atlasMappingHandler = null;</span>
<span class="fc" id="L100">    private String mappingDefinitionId = &quot;0&quot;;</span>
<span class="fc" id="L101">    private DocumentCatalog documentCatalog = new DocumentCatalog();</span>
<span class="fc" id="L102">    private boolean ignoreLibrary = false;</span>
    private ReloadableClassLoader libraryLoader;
    private Path persistDirectory;
    private Path libraryDirectory;
    
    /**
     * A constructor.
     */
    public ADMArchiveHandler() {
<span class="fc" id="L111">        this(ADMArchiveHandler.class.getClassLoader());</span>
<span class="fc" id="L112">    }</span>

    /**
     * A constructor.
     * @param loader class loader
     */
<span class="fc" id="L118">    public ADMArchiveHandler(ClassLoader loader) {</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">        if (loader instanceof ReloadableClassLoader) {</span>
<span class="fc" id="L120">            this.libraryLoader = (ReloadableClassLoader) loader;</span>
        }
<span class="fc" id="L122">        this.jsonMapper = Json.withClassLoader(loader);</span>
<span class="fc" id="L123">        this.jsonMapperForDigest = this.jsonMapper.copy();</span>
<span class="fc" id="L124">        this.jsonMapperForDigest.configure(DeserializationFeature.UNWRAP_ROOT_VALUE, false);</span>
<span class="fc" id="L125">    }</span>

    /**
     * Load an ADM archive file, an exploded directory or mapping definition JSON file.
     * @param path {@link java.nio.file.Path} of the ADM archive file or an exploded directory
     * @throws AtlasException If it fails to load
     */
    public void load(Path path) throws AtlasException {
<span class="fc" id="L133">        clear();</span>
<span class="fc" id="L134">        File file = path.toFile();</span>
<span class="pc bpc" id="L135" title="2 of 6 branches missed.">        if (!file.exists() || (!file.isFile() &amp;&amp; !file.isDirectory())) {</span>
<span class="nc" id="L136">            throw new AtlasException(</span>
<span class="nc" id="L137">                    String.format(&quot;'%s' doesn't exist or is not a regular file/directory&quot;, path.toString()));</span>
        }

<span class="fc bfc" id="L140" title="All 2 branches covered.">        if (file.isDirectory()) {</span>
<span class="fc" id="L141">            loadExploded(file);</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">        } else if (file.getName().toLowerCase().endsWith(&quot;.adm&quot;)){</span>
<span class="fc" id="L143">            loadADMFile(file);</span>
        } else {
<span class="fc" id="L145">            try (FileInputStream fin = new FileInputStream(file)) {</span>
<span class="fc" id="L146">                setMappingDefinitionFromStream(fin);</span>
<span class="nc" id="L147">            } catch (Exception e) {</span>
<span class="nc" id="L148">                throw new AtlasException(</span>
<span class="nc" id="L149">                        String.format(&quot;Invalid mapping definition file: '%s'&quot;, path.toString()), e);</span>
<span class="fc" id="L150">            }</span>
        }
<span class="fc" id="L152">    }</span>

    /**
     * Load an ADM archive from stream.
     * @param in InputStream to read an ADM Archive
     * @throws AtlasException If it fails to load
     */
    public void load(InputStream in) throws AtlasException {
<span class="fc" id="L160">        load(AtlasContextFactory.Format.ADM, in);</span>
<span class="fc" id="L161">    }</span>

    /**
     * Load an ADM archive or mapping definition from stream.
     * @param format {@code AtlasContextFactory.Format} to indicate stream format
     * @param in InputStream to read an ADM Archive
     * @throws AtlasException If it fails to load
     */
    public void load(AtlasContextFactory.Format format, InputStream in) throws AtlasException {
<span class="fc bfc" id="L170" title="All 2 branches covered.">        if (format == AtlasContextFactory.Format.ADM) {</span>
<span class="fc" id="L171">            loadADMStream(in);</span>
        } else {
            try {
<span class="fc" id="L174">                setMappingDefinitionFromStream(in);</span>
<span class="nc" id="L175">            } catch (Exception e) {</span>
<span class="nc" id="L176">                throw new AtlasException(&quot;Invalid mapping definition from stream&quot;, e);</span>
<span class="fc" id="L177">            }</span>
        }
<span class="fc" id="L179">    }</span>

    /**
     * Export into an ADM archive.
     * @param out OutputStream to write an ADM archive
     * @throws AtlasException If it fails to export
     */
    public void export(OutputStream out) throws AtlasException {
<span class="fc" id="L187">        LOG.debug(&quot;Creating ADM archive file for ID:'{}'&quot;, this.mappingDefinitionId);</span>
<span class="fc" id="L188">        try (ZipOutputStream zipOut = new ZipOutputStream(out)) {</span>
<span class="fc" id="L189">            ZipEntry catEntry = null;</span>

<span class="fc bfc" id="L191" title="All 2 branches covered.">            if (getMappingDefinition() != null) {</span>
<span class="fc" id="L192">                String mappingFileName = getMappingDefinitionFileName();</span>
<span class="fc" id="L193">                LOG.debug(&quot;  Creating mapping definition file '{}'&quot;, mappingFileName);</span>
<span class="fc" id="L194">                catEntry = new ZipEntry(mappingFileName);</span>
<span class="fc" id="L195">                zipOut.putNextEntry(catEntry);</span>
<span class="fc" id="L196">                jsonMapper.writeValue(zipOut, getMappingDefinition());</span>
<span class="fc" id="L197">                zipOut.closeEntry();</span>
            }

<span class="pc bpc" id="L200" title="1 of 2 branches missed.">            if (getDocumentCatalog() != null) {</span>
<span class="fc" id="L201">                LOG.debug(&quot;  Creating Document catalog JSON file '{}'&quot;, DOCUMENT_CATALOG_NAME);</span>
<span class="fc" id="L202">                catEntry = new ZipEntry(DOCUMENT_CATALOG_NAME);</span>
<span class="fc" id="L203">                zipOut.putNextEntry(catEntry);</span>
<span class="fc" id="L204">                byte[] serialized = getSerializedDocumentCatalog();</span>
<span class="fc" id="L205">                zipOut.write(serialized, 0, serialized.length);</span>
<span class="fc" id="L206">                zipOut.closeEntry();</span>
            }

<span class="fc" id="L209">            zipOut.putNextEntry(new ZipEntry(SPECIFICATION_DIRECTORY + &quot;/&quot;));</span>
<span class="fc" id="L210">            zipOut.closeEntry();</span>
<span class="fc" id="L211">            Path specDir = getPersistDirectory().resolve(SPECIFICATION_DIRECTORY);</span>
<span class="fc" id="L212">            Path sourceSpecDir = specDir.resolve(DataSourceType.SOURCE.value());</span>
<span class="fc" id="L213">            String entryPath = SPECIFICATION_DIRECTORY + &quot;/&quot; + DataSourceType.SOURCE.value();</span>
<span class="fc" id="L214">            putDocumentResources(sourceSpecDir, entryPath, zipOut);</span>
<span class="fc" id="L215">            Path targetSpecDir = specDir.resolve(DataSourceType.TARGET.value());</span>
<span class="fc" id="L216">            entryPath = SPECIFICATION_DIRECTORY + &quot;/&quot; + DataSourceType.TARGET.value();</span>
<span class="fc" id="L217">            putDocumentResources(targetSpecDir, entryPath, zipOut);</span>
<span class="fc" id="L218">            zipOut.putNextEntry(new ZipEntry(INSPECTED_DIRECTORY+ &quot;/&quot;));</span>
<span class="fc" id="L219">            zipOut.closeEntry();</span>
<span class="fc" id="L220">            Path inspectedDir = getPersistDirectory().resolve(INSPECTED_DIRECTORY);</span>
<span class="fc" id="L221">            Path sourceInspectedDir = inspectedDir.resolve(DataSourceType.SOURCE.value());</span>
<span class="fc" id="L222">            entryPath = INSPECTED_DIRECTORY + &quot;/&quot; + DataSourceType.SOURCE.value();</span>
<span class="fc" id="L223">            putDocumentResources(sourceInspectedDir, entryPath, zipOut);</span>
<span class="fc" id="L224">            Path targetInspectedDir = inspectedDir.resolve(DataSourceType.TARGET.value());</span>
<span class="fc" id="L225">            entryPath = INSPECTED_DIRECTORY + &quot;/&quot; + DataSourceType.TARGET.value();</span>
<span class="fc" id="L226">            putDocumentResources(targetInspectedDir, entryPath, zipOut);</span>

<span class="pc bpc" id="L228" title="2 of 6 branches missed.">            if (!isIgnoreLibrary() &amp;&amp; libraryDirectory != null &amp;&amp; libraryDirectory.toFile().isDirectory()) {</span>
<span class="fc" id="L229">                zipOut.putNextEntry(new ZipEntry(LIB_DIRECTORY + &quot;/&quot;));</span>
<span class="fc" id="L230">                zipOut.closeEntry();</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">                for (File jarFile : libraryDirectory.toFile().listFiles()) {</span>
<span class="fc" id="L232">                    String path = LIB_DIRECTORY + &quot;/&quot; + jarFile.getName();</span>
<span class="fc" id="L233">                    LOG.debug(&quot;  Creating jar file entry '{}'&quot;, path);</span>
<span class="fc" id="L234">                    ZipEntry libEntry = new ZipEntry(path);</span>
<span class="fc" id="L235">                    zipOut.putNextEntry(libEntry);</span>
<span class="fc" id="L236">                    try (FileInputStream fis = new FileInputStream(jarFile)) {</span>
<span class="fc" id="L237">                        fis.transferTo(zipOut);</span>
                    }
<span class="fc" id="L239">                    zipOut.closeEntry();</span>
                }
            }
<span class="nc" id="L242">        } catch (Exception e) {</span>
<span class="nc" id="L243">            throw new AtlasException(&quot;Error exporting ADM archive file&quot;, e);</span>
<span class="fc" id="L244">        }</span>
<span class="fc" id="L245">    }</span>

    private void putDocumentResources(Path sourceParentPath, String targetParentPath, ZipOutputStream zipOut) throws Exception {
<span class="fc bfc" id="L248" title="All 2 branches covered.">        if (!sourceParentPath.toFile().exists()) {</span>
<span class="fc" id="L249">            return;</span>
        }
<span class="fc bfc" id="L251" title="All 2 branches covered.">        for (File dir : sourceParentPath.toFile().listFiles(f -&gt; f.isDirectory())) {</span>
<span class="fc" id="L252">            Path docDir = sourceParentPath.resolve(dir.getName());</span>
<span class="fc" id="L253">            String docDirEntryPath = targetParentPath + &quot;/&quot; + dir.getName();</span>
<span class="fc" id="L254">            zipOut.putNextEntry(new ZipEntry(docDirEntryPath + &quot;/&quot;));</span>
<span class="fc" id="L255">            zipOut.closeEntry();</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">            for (File f : docDir.toFile().listFiles(f -&gt; f.isFile())) {</span>
<span class="fc" id="L257">                String fileEntryPath = docDirEntryPath + &quot;/&quot; + f.getName();</span>
<span class="fc" id="L258">                LOG.debug(&quot;  Creating file entry '{}'&quot;, fileEntryPath);</span>
<span class="fc" id="L259">                zipOut.putNextEntry(new ZipEntry(fileEntryPath));</span>
<span class="fc" id="L260">                try (FileInputStream fis = new FileInputStream(f)) {</span>
<span class="fc" id="L261">                    fis.transferTo(zipOut);</span>
                }
<span class="fc" id="L263">                zipOut.closeEntry();</span>
            }
        }
<span class="fc" id="L266">    }</span>

    /**
     * Persist ADM archive into a directory.
     * @throws AtlasException If it fails to persist
     */
    public void persist() throws AtlasException {
<span class="fc" id="L273">        Path mdPath = getPersistDirectory().resolve(getMappingDefinitionFileName());</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">        if (getMappingDefinition()  != null) {</span>
            try {
<span class="fc" id="L276">                jsonMapper.writeValue(mdPath.toFile(), getMappingDefinition());</span>
<span class="nc" id="L277">            } catch (Exception e) {</span>
<span class="nc" id="L278">                LOG.warn(&quot;Failed to persist mapping definition&quot;, e);</span>
<span class="fc" id="L279">            }</span>
        }

<span class="fc" id="L282">        Path catalogPath = getPersistDirectory().resolve(DOCUMENT_CATALOG_NAME);</span>
<span class="fc bfc" id="L283" title="All 2 branches covered.">        if (getDocumentCatalog() != null) {</span>
            try {
<span class="fc" id="L285">                jsonMapper.writeValue(catalogPath.toFile(), getDocumentCatalog());</span>
<span class="nc" id="L286">            } catch (Exception e) {</span>
<span class="nc" id="L287">                LOG.warn(&quot;Failed to persist Document catalog file&quot;, e);</span>
<span class="fc" id="L288">            }</span>
        }
<span class="fc" id="L290">    }</span>

    /**
     * Gets the {@link AtlasMapping} mapping definition.
     * @return mapping definition
     */
    public AtlasMapping getMappingDefinition() {
<span class="fc" id="L297">        return this.mappingDefinition;</span>
    }

    /**
     * Gets the {@link AtlasMappingHandler}.
     * @return handler
     */
    public AtlasMappingHandler getAtlasMappingHandler() {
<span class="fc bfc" id="L305" title="All 2 branches covered.">        if (this.atlasMappingHandler == null) {</span>
<span class="pc bpc" id="L306" title="1 of 2 branches missed.">            if (this.mappingDefinition == null) {</span>
<span class="fc" id="L307">                this.mappingDefinition = new AtlasMapping();</span>
            }
<span class="fc" id="L309">            this.atlasMappingHandler = new AtlasMappingHandler(this.mappingDefinition);</span>
        }
<span class="fc" id="L311">        return this.atlasMappingHandler;</span>
    }

    /**
     * Gets the serialized {@link AtlasMapping} in byte array.
     * @return serialized
     */
    public byte[] getSerializedMappingDefinition() throws AtlasException {
<span class="fc bfc" id="L319" title="All 2 branches covered.">        if (getMappingDefinition() == null) {</span>
<span class="fc" id="L320">            return null;</span>
        }
        try {
<span class="fc" id="L323">            ByteArrayOutputStream bos = new ByteArrayOutputStream();</span>
<span class="fc" id="L324">            jsonMapper.writeValue(bos, getMappingDefinition());</span>
<span class="fc" id="L325">            return bos.toByteArray();</span>
<span class="nc" id="L326">        } catch (Exception e) {</span>
<span class="nc" id="L327">            throw new AtlasException(&quot;Failed to serialize mapping definition&quot;, e);</span>
        }
    }

    /**
     * Sets the {@link AtlasMapping} mapping definition.
     * @param mapping mapping definition
     */
    public void setMappingDefinition(AtlasMapping mapping) {
<span class="fc" id="L336">        this.mappingDefinition = mapping;</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">        if (AtlasUtil.isEmpty(mapping.getName())) {</span>
<span class="fc" id="L338">            mapping.setName(mappingDefinitionId);</span>
        }
<span class="fc" id="L340">        this.atlasMappingHandler = new AtlasMappingHandler(mapping);</span>
<span class="fc" id="L341">    }</span>

    /**
     * Sets the serialized mapping definition JSON from InputStream.
     * @param is serialized mapping definition JSON
     * @throws AtlasException unexpected error
     */
    public void setMappingDefinitionFromStream(InputStream is) throws AtlasException {
        try {
<span class="fc" id="L350">            setMappingDefinition(jsonMapper.readValue(is, AtlasMapping.class));</span>
<span class="fc" id="L351">        } catch (Exception e) {</span>
<span class="fc" id="L352">            throw new AtlasException(e);</span>
<span class="fc" id="L353">        }</span>
<span class="fc" id="L354">    }</span>

    /**
     * Looks up the DataSource metadata associated with the specified Document ID.
     * @param dstype DataSourceType to indicate SOURCE or TARGET
     * @param documentId Document ID
     * @return DataSource metadata
     * @throws AtlasException unexpected error
     */
    public DocumentMetadata getDocumentMetadata(DataSourceType dstype, String documentId) throws AtlasException {
<span class="nc" id="L364">        return getDocumentMetadata(new DocumentKey(dstype, documentId));</span>
    }

    /**
     * Looks up the DataSource metadata associated with the specified DataSource key.
     * @param key DataSource key
     * @return DataSource metadata
     * @throws AtlasException unexpected error
     */
    public DocumentMetadata getDocumentMetadata(DocumentKey key) throws AtlasException {
<span class="pc bpc" id="L374" title="1 of 2 branches missed.">        if (getDocumentCatalog() == null) {</span>
<span class="nc" id="L375">            return null;</span>
        }
<span class="fc bfc" id="L377" title="All 2 branches covered.">        List&lt;DocumentMetadata&gt; docs = key.getDataSourceType() == DataSourceType.SOURCE</span>
<span class="fc" id="L378">            ? getDocumentCatalog().getSources()</span>
<span class="fc" id="L379">            : getDocumentCatalog().getTargets();</span>
<span class="fc" id="L380">        Optional&lt;DocumentMetadata&gt; answer = docs.stream().filter(m -&gt; key.getDocumentId().equals(m.getId())).findFirst();</span>
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">        if (answer.isPresent()) {</span>
<span class="fc" id="L382">            return answer.get();</span>
        }
<span class="nc" id="L384">        return null;</span>
    }

    /**
     * Sets the InspectionRequest object as a Document metadata.
     * @param documentKey DocumentKey
     * @param metadata DocumentMetadata
     */
    public void setDocumentMetadata(DocumentKey documentKey, DocumentMetadata metadata) throws AtlasException {
<span class="fc bfc" id="L393" title="All 2 branches covered.">        if (getDocumentCatalog() == null) {</span>
<span class="fc" id="L394">            setDocumentCatalog(new DocumentCatalog());</span>
        }
<span class="fc bfc" id="L396" title="All 2 branches covered.">        List&lt;DocumentMetadata&gt; docs = documentKey.getDataSourceType() == DataSourceType.SOURCE</span>
<span class="fc" id="L397">            ? getDocumentCatalog().getSources()</span>
<span class="fc" id="L398">            : getDocumentCatalog().getTargets();</span>
<span class="fc" id="L399">        Optional&lt;DocumentMetadata&gt; meta = docs.stream().filter(m -&gt; documentKey.getDocumentId().equals(m.getId())).findFirst();</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">        if (meta.isPresent()) {</span>
<span class="fc" id="L401">            int index = docs.indexOf(meta.get());</span>
<span class="fc" id="L402">            docs.set(index, metadata);</span>
<span class="fc" id="L403">        } else {</span>
<span class="fc" id="L404">            docs.add(metadata);</span>
        }
<span class="fc" id="L406">    }</span>

    /**
     * Sets the DocumentCatalog.
     * @param catalog catalog
     */
    public void setDocumentCatalog(DocumentCatalog catalog) {
<span class="fc" id="L413">        this.documentCatalog = catalog;</span>
<span class="fc" id="L414">    }</span>

    /**
     * Gets a map of Document metadata.
     * @return a map of Document metadata.
     * @throws AtlasException unexpected error
     */
    public DocumentCatalog getDocumentCatalog() throws AtlasException {
<span class="fc" id="L422">        return this.documentCatalog;</span>
    }

    /**
     * Serializes the {@link DocumentCatalog} into JSON and return as a byte array.
     * @return serialized {@link DocumentCatalog}
     * @throws AtlasException unexpected error
     */
    public byte[] getSerializedDocumentCatalog() throws AtlasException {
<span class="fc bfc" id="L431" title="All 2 branches covered.">        if (getDocumentCatalog() == null) {</span>
<span class="fc" id="L432">            return null;</span>
        }
        try {
<span class="fc" id="L435">            ByteArrayOutputStream bos = new ByteArrayOutputStream();</span>
<span class="fc" id="L436">            jsonMapper.writeValue(bos, getDocumentCatalog());</span>
<span class="fc" id="L437">            return bos.toByteArray();</span>
<span class="nc" id="L438">        } catch (Exception e) {</span>
<span class="nc" id="L439">            throw new AtlasException(&quot;Failed to serialize Document catalog&quot;, e);</span>
        }
    }

    /**
     * Sets a map of Document metadata from InputStream.
     * @param is Document catalog InputStream
     * @throws AtlasException unexpected error
     */
    public void setDocumentCatalogFromStream(InputStream is) throws AtlasException {
        try {
<span class="fc" id="L450">            this.documentCatalog = jsonMapper.readValue(is, DocumentCatalog.class);</span>
<span class="nc" id="L451">        } catch (Exception e) {</span>
<span class="nc" id="L452">            throw new AtlasException(e);</span>
<span class="fc" id="L453">        }</span>
<span class="fc" id="L454">    }</span>

    /**
     * Clones a {@link AtlasMapping} mapping definition object.
     * @return mapping definition
     * @throws AtlasException unexpected error
     */
    public AtlasMapping cloneMappingDefinition() throws AtlasException {
<span class="fc" id="L462">        AtlasMapping atlasMapping = getMappingDefinition();</span>
<span class="pc bpc" id="L463" title="1 of 2 branches missed.">        if (atlasMapping == null) {</span>
<span class="nc" id="L464">            return null;</span>
        }
        try {
<span class="fc" id="L467">            byte[] bytes = this.jsonMapper.writeValueAsBytes(atlasMapping);</span>
<span class="fc" id="L468">            return this.jsonMapper.readValue(bytes, AtlasMapping.class);</span>
<span class="nc" id="L469">        } catch (Exception e) {</span>
<span class="nc" id="L470">            throw new AtlasException(e);</span>
        }
    }

    /**
     * Clears all contents.
     */
    public void clear() throws AtlasException {
<span class="fc" id="L478">        this.mappingDefinition = null;</span>
<span class="fc" id="L479">        this.atlasMappingHandler = null;</span>
<span class="fc" id="L480">        this.documentCatalog = null;</span>
<span class="fc bfc" id="L481" title="All 2 branches covered.">        if (getPersistDirectory().resolve(SPECIFICATION_DIRECTORY).toFile().exists()) {</span>
<span class="fc bfc" id="L482" title="All 2 branches covered.">            for (File f : getPersistDirectory().resolve(SPECIFICATION_DIRECTORY).toFile().listFiles()) {</span>
<span class="fc" id="L483">                AtlasUtil.deleteDirectory(f);</span>
            }
            
        }
<span class="fc bfc" id="L487" title="All 2 branches covered.">        if (getPersistDirectory().resolve(INSPECTED_DIRECTORY).toFile().exists()) {</span>
<span class="fc bfc" id="L488" title="All 2 branches covered.">            for (File f : getPersistDirectory().resolve(INSPECTED_DIRECTORY).toFile().listFiles()) {</span>
<span class="fc" id="L489">                AtlasUtil.deleteDirectory(f);</span>
            }
            
        }
<span class="fc bfc" id="L493" title="All 2 branches covered.">        if (getPersistDirectory().resolve(getMappingDefinitionFileName()).toFile().exists()) {</span>
<span class="fc" id="L494">            getPersistDirectory().resolve(getMappingDefinitionFileName()).toFile().delete();</span>
        }
<span class="pc bpc" id="L496" title="1 of 2 branches missed.">        if (getPersistDirectory().resolve(DOCUMENT_CATALOG_NAME).toFile().exists()) {</span>
<span class="nc" id="L497">            getPersistDirectory().resolve(DOCUMENT_CATALOG_NAME).toFile().delete();</span>
        }
<span class="fc" id="L499">    }</span>

    /**
     * Sets if it ignores the library or not.
     * @param ignoreLib true to ignore library, or false
     */
    public void setIgnoreLibrary(boolean ignoreLib) {
<span class="fc" id="L506">        this.ignoreLibrary = ignoreLib;</span>
<span class="fc" id="L507">    }</span>

    /**
     * Gets if it ignores the library or not.
     * @return true if it ignores library, or false
     */
    public boolean isIgnoreLibrary() {
<span class="fc" id="L514">        return this.ignoreLibrary;</span>
    }

    /**
     * Sets the persistent directory.
     * @param dir persistent directory path
     * @throws AtlasException unexpected error
     */
    public void setPersistDirectory(Path dir) throws AtlasException {
<span class="fc" id="L523">        ensureDirectory(dir);</span>
<span class="fc" id="L524">        this.persistDirectory = dir;</span>
<span class="fc" id="L525">    }</span>

    /**
     * Gets the persistent directory.
     * @return persistent directory path
     * @throws AtlasException unexpected error
     */
    public Path getPersistDirectory() throws AtlasException {
<span class="fc bfc" id="L533" title="All 2 branches covered.">        if (this.persistDirectory == null) {</span>
            try {
<span class="fc" id="L535">                this.persistDirectory = Files.createTempDirectory(&quot;atlasmap&quot;);</span>
<span class="fc" id="L536">                this.persistDirectory.toFile().deleteOnExit();</span>
<span class="nc" id="L537">            } catch (IOException e) {</span>
<span class="nc" id="L538">                throw new AtlasException(&quot;Failed to create a temporary directory to extract the ADM file&quot;, e);</span>
<span class="fc" id="L539">            }</span>
        }
<span class="fc" id="L541">        return this.persistDirectory;</span>
    }

    /**
     * Sets the library directory.
     * @param dir library directory path
     * @throws AtlasException unexpected error
     */
    public void setLibraryDirectory(Path dir) throws AtlasException {
<span class="fc" id="L550">        ensureDirectory(dir);</span>
<span class="fc" id="L551">        this.libraryDirectory = dir;</span>
<span class="fc" id="L552">    }</span>

    /**
     * Sets the mapping definition ID.
     * @param id mapping definition ID
     */
    public void setMappingDefinitionId(String id) {
<span class="fc" id="L559">        this.mappingDefinitionId = id;</span>
<span class="fc" id="L560">    }</span>

    /**
     * Gets the file name of the mapping definition JSON.
     * @return file name
     */
    public String getMappingDefinitionFileName() {
<span class="fc" id="L567">        return String.format(MAPPING_DEFINITION_TEMPLATE, this.mappingDefinitionId);</span>
    }

    /**
     * Sets the Document specification.
     * @param documentKey DocumentKey
     * @param name file name
     * @param specification Document specification
     */
    public void setDocumentSpecification(DocumentKey documentKey, String name, InputStream specification) throws AtlasException {
<span class="fc" id="L577">        Path dsTypePath = getPersistDirectory().resolve(SPECIFICATION_DIRECTORY).resolve(documentKey.getDataSourceType().value());</span>
<span class="fc" id="L578">        ensureDirectory(dsTypePath);</span>
<span class="fc" id="L579">        Path docPath = dsTypePath.resolve(documentKey.getDocumentId());</span>
<span class="fc" id="L580">        AtlasUtil.deleteDirectory(docPath.toFile());</span>
<span class="fc" id="L581">        ensureDirectory(docPath);</span>
<span class="fc" id="L582">        Path filePath = docPath.resolve(name);</span>
<span class="fc" id="L583">        try (FileOutputStream fos = new FileOutputStream(filePath.toFile(), false)) {</span>
<span class="fc" id="L584">            specification.transferTo(fos);</span>
<span class="nc" id="L585">        } catch (Exception e) {</span>
<span class="nc" id="L586">            LOG.warn(String.format(&quot;Failed to save a specification file '%s', ignoring...&quot;, filePath.toString()), e);</span>
<span class="fc" id="L587">        }</span>
<span class="fc" id="L588">    }</span>

    /**
     * Sets the Document specification.
     * @param documentKey DocumentKey
     * @param specification Document specification
     */
    public void setDocumentSpecification(DocumentKey documentKey, InputStream specification) throws AtlasException {
<span class="fc" id="L596">        setDocumentSpecification(documentKey, &quot;0&quot;, specification);</span>
<span class="fc" id="L597">    }</span>

    /**
     * Sets the Document specification.
     * @param dsType DataSourceType indicating SOURCE or TARGET
     * @param docId Document ID
     * @param in input stream
     * @throws AtlasException
     */
    public void setDocumentSpecificationFile(String dsType, String docId, InputStream in) throws AtlasException {
<span class="fc" id="L607">        setDocumentSpecification(new DocumentKey(DataSourceType.fromValue(dsType), docId), in);</span>
<span class="fc" id="L608">    }</span>

    /**
     * Gets the Document specification file handler.
     * @param docKey DocumentKey
     * @return file handler
     */
    public File getDocumentSpecificationFile(DocumentKey docKey) throws AtlasException {
<span class="fc" id="L616">        File specDir = getDocumentSpecificationDirectory(docKey);</span>
<span class="pc bpc" id="L617" title="2 of 6 branches missed.">        if (!specDir.exists() || !specDir.isDirectory() || specDir.list().length != 1) {</span>
<span class="fc" id="L618">            return null;</span>
        }
<span class="fc" id="L620">        return specDir.listFiles()[0];</span>
    }
  
    private File getDocumentSpecificationDirectory(DocumentKey docKey) throws AtlasException {
<span class="fc" id="L624">        return getPersistDirectory()</span>
<span class="fc" id="L625">            .resolve(SPECIFICATION_DIRECTORY)</span>
<span class="fc" id="L626">            .resolve(docKey.getDataSourceType().value())</span>
<span class="fc" id="L627">            .resolve(docKey.getDocumentId())</span>
<span class="fc" id="L628">            .toFile();</span>
    }

    /**
     * Sets the Document inspection result.
     * @param documentKey DocumentKey
     * @param resultObject Document inspection result object
     * @throws AtlasException unexpected error
     */
    public void setDocumentInspectionResult(DocumentKey documentKey, Serializable resultObject) throws AtlasException {
<span class="fc" id="L638">        Path docPath = getPersistDirectory()</span>
<span class="fc" id="L639">            .resolve(INSPECTED_DIRECTORY)</span>
<span class="fc" id="L640">            .resolve(documentKey.getDataSourceType().value())</span>
<span class="fc" id="L641">            .resolve(documentKey.getDocumentId());</span>
<span class="fc" id="L642">        AtlasUtil.deleteDirectory(docPath.toFile());</span>
<span class="fc" id="L643">        ensureDirectory(docPath);</span>
<span class="fc" id="L644">        Path filePath = docPath.resolve(INSPECTED_FILE);</span>
<span class="fc" id="L645">        try (FileOutputStream fos = new FileOutputStream(filePath.toFile(), false)) {</span>
<span class="fc" id="L646">            jsonMapper.writeValue(fos, resultObject);</span>
<span class="nc" id="L647">        } catch (Exception e) {</span>
<span class="nc" id="L648">            LOG.warn(String.format(&quot;Failed to save an inspection result JSON file '%s', ignoring...&quot;, filePath.toString()), e);</span>
<span class="fc" id="L649">        }</span>
<span class="fc" id="L650">    }</span>

    /**
     * Store the serialized Document inspection result into a file.
     * @param dsType DataSourceType
     * @param docId Document ID
     * @param in serialized Document inspection result
     * @throws AtlasException unexpected error
     */
    public void setDocumentInspectionResultFile(String dsType, String docId, InputStream in) throws AtlasException {
<span class="fc" id="L660">        setDocumentInspectionResultFile(new DocumentKey(DataSourceType.fromValue(dsType), docId), in);</span>
<span class="fc" id="L661">    }</span>

    /**
     * Store the serialized Document inspection result into a file.
     * @param documentKey DocumentKey to identify the Document
     * @param in serialized Document inspection result
     * @throws AtlasException unexpected error
     */
    public void setDocumentInspectionResultFile(DocumentKey documentKey, InputStream in) throws AtlasException {
<span class="fc" id="L670">        Path docPath = getPersistDirectory()</span>
<span class="fc" id="L671">            .resolve(INSPECTED_DIRECTORY)</span>
<span class="fc" id="L672">            .resolve(documentKey.getDataSourceType().value())</span>
<span class="fc" id="L673">            .resolve(documentKey.getDocumentId());</span>
<span class="fc" id="L674">        ensureDirectory(docPath);</span>
<span class="fc" id="L675">        Path filePath = docPath.resolve(INSPECTED_FILE);</span>
<span class="fc" id="L676">        try (FileOutputStream fos = new FileOutputStream(filePath.toFile(), false)) {</span>
<span class="fc" id="L677">            in.transferTo(fos);</span>
<span class="nc" id="L678">        } catch (Exception e) {</span>
<span class="nc" id="L679">            LOG.warn(String.format(&quot;Failed to save an inspection result JSON file '%s', ignoring...&quot;, filePath.toString()), e);</span>
<span class="fc" id="L680">        }</span>
<span class="fc" id="L681">    }</span>

    /**
     * Gets the {@link File} which represents the persisted Document inspection result file.
     * @param documentKey DocumentKey to identify the Document
     * @return {@link File} for the persisted Document inspection result file
     * @throws AtlasException unexpected error
     */
    public File getDocumentInspectionResultFile(DocumentKey documentKey) throws AtlasException {
<span class="fc" id="L690">        File inspectedDir = getDocumentInspectionResultDirectory(documentKey);</span>
<span class="pc bpc" id="L691" title="2 of 6 branches missed.">        if (!inspectedDir.exists() || !inspectedDir.isDirectory() || inspectedDir.list().length != 1) {</span>
<span class="fc" id="L692">            return null;</span>
        }
<span class="fc" id="L694">        return inspectedDir.listFiles()[0];</span>
    }

    private File getDocumentInspectionResultDirectory(DocumentKey documentKey) throws AtlasException {
<span class="fc" id="L698">        return getPersistDirectory()</span>
<span class="fc" id="L699">            .resolve(INSPECTED_DIRECTORY)</span>
<span class="fc" id="L700">            .resolve(documentKey.getDataSourceType().value())</span>
<span class="fc" id="L701">            .resolve(documentKey.getDocumentId())</span>
<span class="fc" id="L702">            .toFile();</span>
    }

    /**
     * Deletes the Document specification, inspection result and metadata from the {@link DocumentCatalog}.
     * @param dsType SOURCE or TARGET
     * @param documentId Document ID of the Document to be deleted
     */
    public void deleteDocument(DataSourceType dsType, String documentId) throws AtlasException {
<span class="nc" id="L711">        deleteDocument(new DocumentKey(dsType, documentId));</span>
<span class="nc" id="L712">    }</span>

    /**
     * Deletes the Document specification, inspection result and metadata from the {@link DocumentCatalog}.
     * @param docKey DocumentKey
     */
    public void deleteDocument(DocumentKey docKey) throws AtlasException {
<span class="fc" id="L719">        DocumentCatalog catalog = getDocumentCatalog();</span>
<span class="pc bpc" id="L720" title="1 of 2 branches missed.">        List&lt;DocumentMetadata&gt; docs = docKey.getDataSourceType() == DataSourceType.SOURCE ? catalog.getSources() : catalog.getTargets();</span>
<span class="fc" id="L721">        Optional&lt;DocumentMetadata&gt; todelete = docs.stream().filter(m -&gt; m.getId().equals(docKey.getDocumentId())).findAny();</span>
<span class="pc bpc" id="L722" title="1 of 2 branches missed.">        if (!todelete.isPresent()) {</span>
<span class="nc" id="L723">            return;</span>
        }
<span class="fc" id="L725">        docs.remove(todelete.get());</span>
<span class="fc" id="L726">        File specDir = getDocumentSpecificationDirectory(docKey);</span>
<span class="pc bpc" id="L727" title="2 of 4 branches missed.">        if (specDir != null &amp;&amp; specDir.exists()) {</span>
<span class="fc" id="L728">            AtlasUtil.deleteDirectory(specDir);</span>
        }
<span class="fc" id="L730">        File inspectedDir = getDocumentInspectionResultDirectory(docKey);</span>
<span class="pc bpc" id="L731" title="2 of 4 branches missed.">        if (inspectedDir != null &amp;&amp; specDir.exists()) {</span>
<span class="nc" id="L732">            AtlasUtil.deleteDirectory(inspectedDir);</span>
        }
<span class="fc" id="L734">    }</span>

    /**
     * Loads ADM Archive from an exploded directory.
     * @param dir directory path.
     * @throws AtlasException unexpected error
     */
    private void loadExploded(File dir) throws AtlasException {
<span class="fc" id="L742">        setPersistDirectory(dir.toPath());</span>
<span class="fc" id="L743">        this.mappingDefinitionId = dir.getName();</span>
<span class="fc" id="L744">        File mappingDefinitionFile = dir.toPath().resolve(getMappingDefinitionFileName()).toFile();</span>
<span class="pc bpc" id="L745" title="1 of 4 branches missed.">        if (mappingDefinitionFile.exists() &amp;&amp; mappingDefinitionFile.isFile()) {</span>
<span class="fc" id="L746">            try (InputStream mappingdefis = new FileInputStream(mappingDefinitionFile)) {</span>
<span class="fc" id="L747">                setMappingDefinitionFromStream(mappingdefis);</span>
<span class="nc" id="L748">            } catch (Exception e) {</span>
<span class="nc" id="L749">                throw new AtlasException(&quot;Failed to read mapping definition file&quot;, e);</span>
<span class="fc" id="L750">            }</span>
        }

<span class="fc" id="L753">        File catalogFile = dir.toPath().resolve(DOCUMENT_CATALOG_NAME).toFile();</span>
<span class="pc bpc" id="L754" title="1 of 4 branches missed.">        if (catalogFile.exists() &amp;&amp; catalogFile.isFile()) {</span>
<span class="fc" id="L755">            try (InputStream catalogis = new FileInputStream(catalogFile)) {</span>
<span class="fc" id="L756">                setDocumentCatalogFromStream(catalogis);</span>
<span class="nc" id="L757">            } catch (Exception e) {</span>
<span class="nc" id="L758">                throw new AtlasException(&quot;Failed to read document catalog file&quot;, e);</span>
<span class="fc" id="L759">            }</span>
        }
<span class="fc" id="L761">    }</span>

    private void loadADMFile(File file) throws AtlasException {
<span class="fc" id="L764">        try (FileInputStream fis = new FileInputStream(file)) {</span>
<span class="fc" id="L765">            loadADMStream(fis);</span>
<span class="nc" id="L766">        } catch (AtlasException ae) {</span>
<span class="nc" id="L767">            throw ae;</span>
<span class="nc" id="L768">        } catch (Exception e) {</span>
<span class="nc" id="L769">            throw new AtlasException(e);</span>
<span class="fc" id="L770">        }</span>
<span class="fc" id="L771">    }</span>

    private void loadADMStream(InputStream in) throws AtlasException {
        String catEntryName;
        ZipEntry catEntry;
<span class="fc" id="L776">        try (ZipInputStream zipIn = new ZipInputStream(in)) {</span>
<span class="fc" id="L777">            boolean mappingDefinitionFound = false;</span>
<span class="fc" id="L778">            boolean libraryFound = false;</span>
<span class="fc bfc" id="L779" title="All 2 branches covered.">            while ((catEntry = zipIn.getNextEntry()) != null) {</span>
<span class="fc bfc" id="L780" title="All 2 branches covered.">                if (catEntry.isDirectory()) {</span>
<span class="fc" id="L781">                    continue;</span>
                }
<span class="fc" id="L783">                catEntryName = cleanSeparator(catEntry.getName());</span>
<span class="fc" id="L784">                LOG.debug(&quot;  Extracting ADM file entry '{}'&quot;, catEntryName);</span>
<span class="fc bfc" id="L785" title="All 2 branches covered.">                if (catEntryName.contains(GZIPPED_ADM_DIGEST_FILTER)) {</span>
<span class="fc" id="L786">                    extractFromGzippedADMDigest(zipIn);</span>
<span class="fc bfc" id="L787" title="All 2 branches covered.">                } else if (catEntryName.contains(DOCUMENT_CATALOG_FILTER)) {</span>
<span class="fc" id="L788">                    setDocumentCatalogFromStream(zipIn);</span>
<span class="fc bfc" id="L789" title="All 2 branches covered.">                } else if (catEntryName.startsWith(SPECIFICATION_DIRECTORY)) {</span>
<span class="fc" id="L790">                    String[] segments = catEntryName.split(&quot;/&quot;);</span>
<span class="pc bpc" id="L791" title="1 of 2 branches missed.">                    if (segments.length != 4) {</span>
<span class="nc" id="L792">                        continue;</span>
                    }
<span class="fc" id="L794">                    setDocumentSpecificationFile(segments[1], segments[2], zipIn);</span>
<span class="fc bfc" id="L795" title="All 2 branches covered.">                } else if (catEntryName.startsWith(INSPECTED_DIRECTORY)) {</span>
<span class="fc" id="L796">                    String[] segments = catEntryName.split(&quot;/&quot;);</span>
<span class="pc bpc" id="L797" title="1 of 2 branches missed.">                    if (segments.length != 4) {</span>
<span class="nc" id="L798">                        continue;</span>
                    }
<span class="fc" id="L800">                    setDocumentInspectionResultFile(segments[1], segments[2], zipIn);</span>
<span class="fc bfc" id="L801" title="All 4 branches covered.">                } else if (!isIgnoreLibrary() &amp;&amp; catEntryName.contains(&quot;.jar&quot;)) {</span>
<span class="pc bpc" id="L802" title="1 of 2 branches missed.">                    if (this.libraryDirectory == null) {</span>
<span class="nc" id="L803">                        throw new AtlasException(&quot;Library directory is not specified&quot;);</span>
                    }
<span class="fc" id="L805">                    int separatorPos = catEntryName.lastIndexOf(&quot;/&quot;);</span>
<span class="pc bpc" id="L806" title="1 of 2 branches missed.">                    String name = separatorPos == -1 ? catEntryName : catEntryName.substring(separatorPos + 1);</span>
<span class="fc" id="L807">                    Path libPath = this.libraryDirectory.resolve(name);</span>
<span class="fc" id="L808">                    try (FileOutputStream fos = new FileOutputStream(libPath.toFile(), false)) {</span>
<span class="fc" id="L809">                        zipIn.transferTo(fos);</span>
<span class="fc" id="L810">                        libraryFound = true;</span>
<span class="nc" id="L811">                    } catch (Exception e) {</span>
<span class="nc" id="L812">                        LOG.warn(String.format(&quot;Failed to save a jar file '%s', ignoring...&quot;, name), e);</span>
<span class="fc" id="L813">                    }</span>
<span class="fc bfc" id="L814" title="All 2 branches covered.">                } else if (catEntryName.contains(MAPPING_DEFINITION_FILTER)) {</span>
<span class="pc bpc" id="L815" title="1 of 2 branches missed.">                    if (mappingDefinitionFound) {</span>
<span class="nc" id="L816">                        throw new AtlasException(&quot;Multiple mapping definition files are found in a same .adm archive&quot;);</span>
                    }
<span class="fc" id="L818">                    ensureDirectory(getPersistDirectory());</span>
<span class="fc" id="L819">                    Path mdPath = getPersistDirectory().resolve(getMappingDefinitionFileName());</span>
<span class="fc" id="L820">                    zipIn.transferTo(new FileOutputStream(mdPath.toFile()));</span>
<span class="fc" id="L821">                    mappingDefinitionFound = true;</span>
<span class="fc" id="L822">                } else {</span>
<span class="fc" id="L823">                    LOG.debug(&quot;Ignoring file '{}' in .adm archive&quot;, catEntryName);</span>
                }
            }
<span class="fc bfc" id="L826" title="All 4 branches covered.">            if (libraryFound &amp;&amp; this.libraryLoader != null) {</span>
<span class="fc" id="L827">                this.libraryLoader.reload();</span>
            }
            // MappingDefinition potentially needs the custom Java classes to be loaded to deserialize
<span class="fc bfc" id="L830" title="All 2 branches covered.">            if (mappingDefinitionFound) {</span>
<span class="fc" id="L831">                Path mdPath = getPersistDirectory().resolve(getMappingDefinitionFileName());</span>
<span class="fc" id="L832">                setMappingDefinitionFromStream(new FileInputStream(mdPath.toFile()));</span>
            }
<span class="nc" id="L834">        } catch (Exception e) {</span>
<span class="nc" id="L835">            throw new AtlasException(e);</span>
<span class="fc" id="L836">        }</span>
<span class="fc" id="L837">    }</span>

    private String cleanSeparator(String path) {
<span class="pc bpc" id="L840" title="1 of 2 branches missed.">        return path != null ? path.replaceAll(&quot;\\\\&quot;, &quot;/&quot;) : null;</span>
    }

    /**
     * Extracts Document metadata and specification from gzipped ADMDigest. It will be converted to
     * the DocumentCatalog and individual specification/inspected files.
     * @param in gzipped ADMDigest JSON file
     * @deprecated {@link ADMDigest} is kept for backward compatibility. It is recommended to convert the ADM
     * file with the newer version of AtlasMap UI to avoid auto conversion happens everytime the ADM file is loaded.
     */
    @Deprecated
    private void extractFromGzippedADMDigest(InputStream in) throws AtlasException {
        try {
<span class="fc" id="L853">            GZIPInputStream gzipped = new GZIPInputStream(in);</span>
<span class="fc" id="L854">            ADMDigest digest = jsonMapperForDigest.readValue(gzipped, ADMDigest.class);</span>
<span class="fc" id="L855">            setDocumentCatalog(new DocumentCatalog());</span>
<span class="fc bfc" id="L856" title="All 2 branches covered.">            for (int i=0; i&lt;digest.getExportMeta().length; i++) {</span>
<span class="fc" id="L857">                DataSourceMetadata meta = digest.getExportMeta()[i];</span>
<span class="fc" id="L858">                String spec = digest.getExportBlockData()[i].getValue();</span>
<span class="fc bfc" id="L859" title="All 2 branches covered.">                if (meta.getId() == null) {</span>
<span class="fc" id="L860">                    meta.setId(meta.getName());</span>
                }
<span class="fc" id="L862">                DocumentMetadata docMeta = createDocumentMetadataFrom(meta);</span>
<span class="fc" id="L863">                DocumentKey docKey = new DocumentKey(docMeta.getDataSourceType(), meta.getId());</span>
<span class="fc" id="L864">                setDocumentMetadata(docKey, docMeta);</span>
<span class="pc bpc" id="L865" title="1 of 2 branches missed.">                if (spec != null) {</span>
<span class="fc" id="L866">                    setDocumentSpecification(docKey, new ByteArrayInputStream(spec.getBytes()));</span>
                }
            }
<span class="nc" id="L869">        } catch (Exception e) {</span>
<span class="nc" id="L870">            throw new AtlasException(e);</span>
<span class="fc" id="L871">        }</span>
<span class="fc" id="L872">    }</span>

    private DocumentMetadata createDocumentMetadataFrom(DataSourceMetadata meta) {
<span class="fc" id="L875">        DocumentMetadata answer = new DocumentMetadata();</span>
<span class="fc" id="L876">        answer.setId(meta.getId());</span>
<span class="fc" id="L877">        answer.setName(meta.getName());</span>
<span class="fc" id="L878">        String docTypeStr = meta.getDocumentType();</span>
<span class="fc bfc" id="L879" title="All 2 branches covered.">        if (docTypeStr != null) {</span>
<span class="fc" id="L880">            answer.setDocumentType(DocumentType.fromValue(docTypeStr.toUpperCase()));</span>
        } else {
            // old adm file has DocumentType as DataSourceType
<span class="fc" id="L883">            docTypeStr = meta.getDataSourceType();</span>
<span class="pc bpc" id="L884" title="1 of 2 branches missed.">            if (docTypeStr != null) {</span>
                try {
<span class="fc" id="L886">                    answer.setDocumentType(DocumentType.fromValue(docTypeStr.toUpperCase()));</span>
<span class="pc" id="L887">                } catch (IllegalArgumentException e) {}</span>
            }
        }
<span class="fc" id="L890">        answer.setInspectionType(meta.getInspectionType());</span>
<span class="fc bfc" id="L891" title="All 2 branches covered.">        answer.setDataSourceType(meta.getIsSource() ? DataSourceType.SOURCE : DataSourceType.TARGET);</span>
<span class="fc" id="L892">        answer.setInspectionParameters(meta.getInspectionParameters());</span>
<span class="fc bfc" id="L893" title="All 2 branches covered.">        if (answer.getDocumentType() == DocumentType.JAVA) {</span>
<span class="fc bfc" id="L894" title="All 2 branches covered.">            if (answer.getInspectionParameters() == null) {</span>
<span class="fc" id="L895">                answer.setInspectionParameters(new HashMap&lt;&gt;());</span>
            }
<span class="pc bpc" id="L897" title="1 of 2 branches missed.">            if (!answer.getInspectionParameters().containsKey(&quot;className&quot;)) {</span>
                // old adm file has the FQCN of the Java Document only as a Document ID
<span class="fc" id="L899">                answer.getInspectionParameters().put(&quot;className&quot;, answer.getId());</span>
            }
        }
<span class="fc" id="L902">        return answer;</span>
    }

    private boolean ensureDirectory(Path dir) throws AtlasException {
<span class="pc bpc" id="L906" title="1 of 2 branches missed.">        if (dir == null) {</span>
<span class="nc" id="L907">            throw new AtlasException(String.format(&quot;Directory must not be Null&quot;));</span>
        }
<span class="fc" id="L909">        File dirf = dir.toFile();</span>
<span class="pc bpc" id="L910" title="1 of 4 branches missed.">        if (dirf.exists() &amp;&amp; !dirf.isDirectory()) {</span>
<span class="nc" id="L911">            throw new AtlasException(String.format(&quot;File '%s' is not a directory&quot;, dirf.getAbsolutePath()));</span>
<span class="fc bfc" id="L912" title="All 2 branches covered.">        } else if (!dirf.exists()) {</span>
<span class="fc" id="L913">            dirf.mkdirs();</span>
        }

<span class="fc" id="L916">        return true;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>