<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AtlasXmlSchemaSetParser.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Unit Test Coverage Report</a> &gt; <a href="../index.html" class="el_bundle">atlas-xml-core</a> &gt; <a href="index.source.html" class="el_package">io.atlasmap.xml.core.schema</a> &gt; <span class="el_source">AtlasXmlSchemaSetParser.java</span></div><h1>AtlasXmlSchemaSetParser.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2017 Red Hat, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.atlasmap.xml.core.schema;

import static io.atlasmap.xml.core.AtlasXmlConstants.NS_PREFIX_SCHEMASET;
import static io.atlasmap.xml.core.AtlasXmlConstants.NS_PREFIX_XMLSCHEMA;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.util.LinkedList;
import java.util.List;

import javax.xml.XMLConstants;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.SAXParserFactory;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathFactory;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.ErrorHandler;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;

import com.sun.xml.xsom.XSSchemaSet;
import com.sun.xml.xsom.parser.XSOMParser;
import com.sun.xml.xsom.util.DomAnnotationParserFactory;

import io.atlasmap.api.AtlasException;
import io.atlasmap.xml.core.AtlasXmlNamespaceContext;

public class AtlasXmlSchemaSetParser {

<span class="fc" id="L63">    private static final Logger LOG = LoggerFactory.getLogger(AtlasXmlSchemaSetParser.class);</span>
    private ClassLoader classLoader;
    private AtlasXmlNamespaceContext namespaceContext;
    private String rootNamespace;
    private SAXParserFactory saxParserFactory;
    private Transformer transformer;
    private DocumentBuilder documentBuilder;

<span class="fc" id="L71">    public AtlasXmlSchemaSetParser(ClassLoader cl) throws AtlasException {</span>
<span class="fc" id="L72">        this.classLoader = cl;</span>
<span class="fc" id="L73">        this.namespaceContext = new AtlasXmlNamespaceContext();</span>
<span class="fc" id="L74">        this.saxParserFactory = SAXParserFactory.newInstance();</span>
        try {
<span class="fc" id="L76">            this.transformer = TransformerFactory.newInstance().newTransformer();</span>
<span class="fc" id="L77">            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span>
<span class="fc" id="L78">            dbf.setNamespaceAware(true);</span>
<span class="fc" id="L79">            this.documentBuilder = dbf.newDocumentBuilder();</span>
<span class="nc" id="L80">        } catch (Exception e) {</span>
<span class="nc" id="L81">            throw new AtlasException(e);</span>
<span class="fc" id="L82">        }</span>
<span class="fc" id="L83">    }</span>

    /**
     * Parse single XML Schema or SchemaSet which contains multiple XML Schema and
     * build a {@link XSSchemaSet}.
     * @param doc DOM {@link Document} instance of XML Schema
     * @return parsed {@link XSSchemaSet}
     * @throws AtlasException If it fails to parse
     */
    public XSSchemaSet parse(Document doc) throws AtlasException {
<span class="fc" id="L93">        XSOMParser xsomParser = createXSOMParser();</span>
<span class="fc" id="L94">        parseInternal(doc, n -&gt; {</span>
            try {
<span class="fc" id="L96">                xsomParser.parse(toInputStream(n));</span>
<span class="fc" id="L97">            } catch (Exception e) {</span>
<span class="fc" id="L98">                throw new AtlasException(e);</span>
<span class="fc" id="L99">            }</span>
<span class="fc" id="L100">        });</span>
        try {
<span class="fc" id="L102">            return xsomParser.getResult();</span>
<span class="nc" id="L103">        } catch (Exception e) {</span>
<span class="nc" id="L104">            throw new AtlasException(e);</span>
        }
    }

    /**
     * Parse XML Schema or SchemaSet which contains multiple XML Schema and
     * build a {@link XSSchemaSet}.
     * @param in {@link InputStream} of XML Schema document
     * @return parsed {@link XSSchemaSet}
     * @throws AtlasException If it fails to parse
     */
    public XSSchemaSet parse(InputStream in) throws AtlasException {
        try {
<span class="fc" id="L117">            Document doc = this.documentBuilder.parse(in);</span>
<span class="fc" id="L118">            return parse(doc);</span>
<span class="fc" id="L119">        } catch (Exception e) {</span>
<span class="fc" id="L120">            throw new AtlasException(e);</span>
        }
    }

    /**
     * Parse single XML Schema or SchemaSet which contains multiple XML Schema and
     * build a {@link Schema}.
     * @param in {@link InputStream} to read schema contents from
     * @return Created {@link Schema}
     * @throws AtlasException If it fails to parse
     */
    public Schema createSchema(InputStream in) throws AtlasException {
<span class="fc" id="L132">        SchemaFactory factory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);</span>
<span class="fc" id="L133">        List&lt;Source&gt; schemaSources = new LinkedList&lt;&gt;();</span>
        Document doc;
        try {
<span class="fc" id="L136">            doc = this.documentBuilder.parse(in);</span>
<span class="fc" id="L137">            parseInternal(doc, n -&gt; {</span>
<span class="fc" id="L138">                DOMSource s = new DOMSource(n);</span>
<span class="fc" id="L139">                schemaSources.add(s);</span>
<span class="fc" id="L140">            });</span>
<span class="fc" id="L141">            factory.setErrorHandler(new NoopErrorHandler());</span>
<span class="fc" id="L142">            return factory.newSchema(schemaSources.toArray(new Source[0]));</span>
<span class="nc" id="L143">        } catch (AtlasException e) {</span>
<span class="nc" id="L144">            throw e;</span>
<span class="nc" id="L145">        } catch (Exception e2) {</span>
<span class="nc" id="L146">            throw new AtlasException(e2);</span>
        }
    }

    public void setNamespaceContext(AtlasXmlNamespaceContext nsc) {
<span class="nc" id="L151">        this.namespaceContext = nsc;</span>
<span class="nc" id="L152">    }</span>

    public AtlasXmlNamespaceContext getNamespaceContext() {
<span class="fc" id="L155">        return this.namespaceContext;</span>
    }

    public void setRootNamespace(String rootns) {
<span class="nc" id="L159">        this.rootNamespace = rootns;</span>
<span class="nc" id="L160">    }</span>

    public String getRootNamespace() {
<span class="fc" id="L163">        return this.rootNamespace;</span>
    }

    private String getTargetNamespace(Node n) {
<span class="fc" id="L167">        NamedNodeMap attributes = n.getAttributes();</span>
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">        if (attributes == null) {</span>
<span class="nc" id="L169">            return &quot;&quot;;</span>
        }
<span class="fc" id="L171">        Attr tns = (Attr) attributes.getNamedItem(&quot;targetNamespace&quot;);</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">        return tns != null ? tns.getValue() : &quot;&quot;;</span>
    }

    @FunctionalInterface
    private interface ParserCallback {
        void addSchema(Node n) throws AtlasException;
    }

<span class="fc" id="L180">    private class NoopErrorHandler implements ErrorHandler {</span>

        @Override
        public void warning(SAXParseException e) throws SAXException {
<span class="nc bnc" id="L184" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L185">                LOG.debug(&quot;warning&quot;, e);</span>
            }
<span class="nc" id="L187">        }</span>

        @Override
        public void error(SAXParseException e) throws SAXException {
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L192">                LOG.debug(&quot;error&quot;, e);</span>
            }
<span class="fc" id="L194">        }</span>

        @Override
        public void fatalError(SAXParseException e) throws SAXException {
<span class="nc bnc" id="L198" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L199">                LOG.debug(&quot;fatalError&quot;, e);</span>
            }
<span class="nc" id="L201">        }</span>
        
    }

    private void parseInternal(Document doc, ParserCallback callback) throws AtlasException {
        try {
<span class="fc" id="L207">            Element root = doc.getDocumentElement();</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">            if (&quot;SchemaSet&quot;.equals(root.getLocalName())) {</span>
<span class="fc" id="L209">                XPath xpath = XPathFactory.newInstance().newXPath();</span>
<span class="fc" id="L210">                xpath.setNamespaceContext(this.namespaceContext);</span>
<span class="fc" id="L211">                NodeList subSchemas = (NodeList) xpath</span>
<span class="fc" id="L212">                        .evaluate(String.format(&quot;/%s:SchemaSet/%s:AdditionalSchemas/%s:schema&quot;, NS_PREFIX_SCHEMASET,</span>
                                NS_PREFIX_SCHEMASET, NS_PREFIX_XMLSCHEMA), root, XPathConstants.NODESET);
<span class="fc bfc" id="L214" title="All 2 branches covered.">                for (int i = 0; i &lt; subSchemas.getLength(); i++) {</span>
<span class="fc" id="L215">                    Element e = (Element) subSchemas.item(i);</span>
<span class="fc" id="L216">                    inheritNamespaces(e, false);</span>
<span class="fc" id="L217">                    callback.addSchema(e);</span>
                }

<span class="fc" id="L220">                Element rootSchema = (Element) xpath.evaluate(</span>
<span class="fc" id="L221">                        String.format(&quot;/%s:SchemaSet/%s:schema&quot;, NS_PREFIX_SCHEMASET, NS_PREFIX_XMLSCHEMA), root,</span>
                        XPathConstants.NODE);
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">                if (rootSchema == null) {</span>
<span class="nc" id="L224">                    throw new AtlasException(</span>
                            &quot;The root schema '/SchemaSet/schema' must be specified once and only once&quot;);
                }
<span class="fc" id="L227">                this.rootNamespace = getTargetNamespace(rootSchema);</span>
<span class="pc bpc" id="L228" title="1 of 4 branches missed.">                if (this.rootNamespace != null &amp;&amp; !this.rootNamespace.isEmpty()) {</span>
<span class="fc" id="L229">                    this.namespaceContext.add(&quot;tns&quot;, this.rootNamespace);</span>
                }
<span class="fc" id="L231">                inheritNamespaces(rootSchema, true);</span>
<span class="fc" id="L232">                callback.addSchema(rootSchema);</span>
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">            } else if (&quot;schema&quot;.equals(root.getLocalName())) {</span>
<span class="fc" id="L234">                callback.addSchema(root);</span>
<span class="fc" id="L235">                this.rootNamespace = getTargetNamespace(root);</span>
<span class="pc bpc" id="L236" title="1 of 4 branches missed.">                if (this.rootNamespace != null &amp;&amp; !this.rootNamespace.isEmpty()) {</span>
<span class="fc" id="L237">                    this.namespaceContext.add(&quot;tns&quot;, this.rootNamespace);</span>
                }
            } else {
<span class="nc" id="L240">                throw new AtlasException(</span>
<span class="nc" id="L241">                        String.format(&quot;Unsupported document element '%s': root element must be 'schema' or 'SchemaSet'&quot;,</span>
<span class="nc" id="L242">                                root.getLocalName()));</span>
            }
<span class="fc" id="L244">        } catch (Exception e) {</span>
<span class="fc" id="L245">            throw new AtlasException(e);</span>
<span class="fc" id="L246">        }</span>
<span class="fc" id="L247">    }</span>

    private XSOMParser createXSOMParser() {
<span class="fc" id="L250">        XSOMParser parser = new XSOMParser(this.saxParserFactory);</span>
<span class="fc" id="L251">        parser.setEntityResolver(new XSOMClasspathEntityResolver(this.classLoader));</span>
<span class="fc" id="L252">        parser.setAnnotationParser(new DomAnnotationParserFactory());</span>
<span class="fc" id="L253">        parser.setErrorHandler(new XSOMErrorHandler());</span>
<span class="fc" id="L254">        return parser;</span>
    }

    private void inheritNamespaces(Element element, boolean updateContext) {
<span class="fc" id="L258">        Node target = element.getParentNode();</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">        while (target != null) {</span>
<span class="fc" id="L260">            NamedNodeMap attributes = target.getAttributes();</span>
<span class="fc bfc" id="L261" title="All 2 branches covered.">            if (attributes != null) {</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">                for (int i = 0; i &lt; attributes.getLength(); i++) {</span>
<span class="fc" id="L263">                    Attr attr = (Attr) attributes.item(i);</span>
<span class="pc bpc" id="L264" title="2 of 4 branches missed.">                    if (&quot;xmlns&quot;.equals(attr.getPrefix()) &amp;&amp; !&quot;xmlns&quot;.equals(attr.getLocalName())) {</span>
<span class="fc" id="L265">                        element.setAttribute(attr.getName(), attr.getValue());</span>
<span class="fc bfc" id="L266" title="All 2 branches covered.">                        if (updateContext) {</span>
<span class="fc" id="L267">                            namespaceContext.add(attr.getLocalName(), attr.getValue());</span>
                        }
                    }
                }
            }
<span class="fc" id="L272">            target = target.getParentNode();</span>
<span class="fc" id="L273">        }</span>
<span class="fc" id="L274">    }</span>

    private ByteArrayInputStream toInputStream(Node n) throws Exception {
<span class="fc" id="L277">        ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="fc" id="L278">        this.transformer.transform(new DOMSource(n), new StreamResult(baos));</span>
<span class="fc" id="L279">        byte[] output = baos.toByteArray();</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">        if (LOG.isTraceEnabled()) {</span>
<span class="fc" id="L281">            LOG.trace(&quot;&gt;&gt;&gt; {}&quot;, new String(output));</span>
        }
<span class="fc" id="L283">        return new ByteArrayInputStream(output);</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>