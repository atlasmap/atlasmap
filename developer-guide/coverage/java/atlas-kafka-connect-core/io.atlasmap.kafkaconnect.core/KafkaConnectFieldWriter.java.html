<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>KafkaConnectFieldWriter.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Unit Test Coverage Report</a> &gt; <a href="../index.html" class="el_bundle">atlas-kafka-connect-core</a> &gt; <a href="index.source.html" class="el_package">io.atlasmap.kafkaconnect.core</a> &gt; <span class="el_source">KafkaConnectFieldWriter.java</span></div><h1>KafkaConnectFieldWriter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2017 Red Hat, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.atlasmap.kafkaconnect.core;

import java.util.LinkedList;
import java.util.List;

import org.apache.kafka.connect.data.ConnectSchema;
import org.apache.kafka.connect.data.Schema;
import org.apache.kafka.connect.data.Struct;
import org.slf4j.LoggerFactory;

import io.atlasmap.api.AtlasException;
import io.atlasmap.core.AtlasPath;
import io.atlasmap.core.AtlasPath.SegmentContext;
import io.atlasmap.spi.AtlasConversionService;
import io.atlasmap.spi.AtlasFieldWriter;
import io.atlasmap.spi.AtlasInternalSession;
import io.atlasmap.v2.AtlasModelFactory;
import io.atlasmap.v2.CollectionType;
import io.atlasmap.v2.Field;

/**
 * The {@link AtlasFieldWriter} implementation for Kafka Connect.
 */
public class KafkaConnectFieldWriter implements AtlasFieldWriter {
<span class="fc" id="L40">    private static final org.slf4j.Logger LOG = LoggerFactory.getLogger(KafkaConnectFieldWriter.class);</span>

    private AtlasConversionService conversionService;
<span class="fc" id="L43">    private Object root = null;</span>
    private org.apache.kafka.connect.data.Schema schema;

    /**
     * A constructor.
     * @param conversion conversion service
     */
<span class="fc" id="L50">    public KafkaConnectFieldWriter(AtlasConversionService conversion) {</span>
<span class="fc" id="L51">        this.conversionService = conversion;</span>
<span class="fc" id="L52">    }</span>

    /**
     * Gets the Document.
     * @return Document
     */
    public Object getDocument() {
<span class="fc" id="L59">        return root;</span>
    }

    /**
     * Sets the schema.
     * @param schema schema
     */
    public void setSchema(org.apache.kafka.connect.data.Schema schema) {
<span class="fc" id="L67">        this.schema = schema;</span>
<span class="fc" id="L68">    }</span>

    @Override
    public void write(AtlasInternalSession session) throws AtlasException {
<span class="fc bfc" id="L72" title="All 2 branches covered.">        if (this.schema == null) {</span>
<span class="fc" id="L73">            throw new AtlasException(&quot;Kafka Connect schema must be set to write Kafka Connect object&quot;);</span>
        }
<span class="fc" id="L75">        Field targetField = session.head().getTargetField();</span>
<span class="pc bpc" id="L76" title="1 of 2 branches missed.">        if (targetField == null) {</span>
<span class="nc" id="L77">            throw new AtlasException(new IllegalArgumentException(&quot;Target field cannot be null&quot;));</span>
        }
<span class="pc bpc" id="L79" title="1 of 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L80">            LOG.debug(&quot;Field: &quot; + AtlasModelFactory.toString(targetField));</span>
<span class="nc" id="L81">            LOG.debug(&quot;Field type=&quot; + targetField.getFieldType() + &quot; path=&quot; + targetField.getPath() + &quot; v=&quot;</span>
<span class="nc" id="L82">                    + targetField.getValue());</span>
        }

<span class="fc" id="L85">        AtlasPath path = new AtlasPath(targetField.getPath());</span>
<span class="fc" id="L86">        this.root = writeSegment(path, 0, root, schema, targetField);</span>
<span class="fc" id="L87">    }</span>

    private Object writeSegment(AtlasPath path, int index, Object parent, Schema parentSchema, Field field) throws AtlasException {
        Object answer;
        Schema schema;
<span class="fc" id="L92">        List&lt;SegmentContext&gt; segments = path.getSegments(true);</span>
<span class="fc" id="L93">        SegmentContext segment = segments.get(index);</span>
        // terminal field
<span class="fc bfc" id="L95" title="All 2 branches covered.">        if (segments.size() == index + 1) {</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">            if (segment.getCollectionType() != CollectionType.NONE) {</span>
<span class="fc" id="L97">                List&lt;Object&gt; collection = new LinkedList&lt;Object&gt;();</span>
<span class="pc bpc" id="L98" title="1 of 2 branches missed.">                if (parent == null) {</span>
<span class="nc" id="L99">                    answer = collection;</span>
                } else {
<span class="fc" id="L101">                    Object array = ((Struct)parent).get(segment.getName());</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">                    if (array == null) {</span>
<span class="fc" id="L103">                        ((Struct)parent).put(segment.getName(), collection);</span>
                    } else {
<span class="fc" id="L105">                        collection = (List&lt;Object&gt;) array;</span>
                    }
<span class="fc" id="L107">                    answer = parent;</span>
                }
<span class="fc" id="L109">                int pos = segment.getCollectionIndex();</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">                while (collection.size() &lt; pos + 1) {</span>
<span class="fc" id="L111">                    collection.add(null);</span>
                }
<span class="fc" id="L113">                collection.set(pos, field.getValue());</span>
<span class="fc" id="L114">            } else {</span>
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">                if (parent == null) {</span>
<span class="nc" id="L116">                    answer = field.getValue();</span>
                } else {
<span class="fc" id="L118">                    ((Struct)parent).put(segment.getName(), field.getValue());</span>
<span class="fc" id="L119">                    answer = parent;</span>
                }
            }
<span class="fc" id="L122">            return answer;</span>
        }

        // non-terminal field

        // non-collection segment
<span class="pc bpc" id="L128" title="1 of 4 branches missed.">        if (segment.getCollectionType() == null || segment.getCollectionType() == CollectionType.NONE) {</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">            if (index == 0) {</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">                answer = root != null ? root : new Struct(enforceDefaultOrOptional(parentSchema));</span>
<span class="fc" id="L131">                schema = parentSchema;</span>
            } else {
<span class="fc" id="L133">                schema = parentSchema.field(segment.getName()).schema();</span>
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">                if (((Struct)parent).getStruct(segment.getName()) == null) {</span>
<span class="fc" id="L135">                    ((Struct)parent).put(segment.getName(), new Struct(schema));</span>
                }
<span class="fc" id="L137">                answer = ((Struct)parent).getStruct(segment.getName());</span>
            }
<span class="fc" id="L139">            writeSegment(path, index + 1, answer, schema, field);</span>
<span class="fc" id="L140">            return answer;</span>
        }

        // collection segment
        List&lt;Object&gt; array;
<span class="fc bfc" id="L145" title="All 2 branches covered.">        if (index == 0) {</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">            array = root != null ? (List&lt;Object&gt;)root : new LinkedList&lt;Object&gt;();</span>
<span class="fc" id="L147">            schema = enforceDefaultOrOptional(parentSchema.valueSchema());</span>
        } else {
<span class="fc" id="L149">            schema = parentSchema.field(segment.getName()).schema().valueSchema();</span>
<span class="fc" id="L150">            array = ((Struct) parent).getArray(segment.getName());</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">            if (array == null) {</span>
<span class="fc" id="L152">                array = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L153">                ((Struct) parent).put(segment.getName(), array);</span>
            }
        }
<span class="fc" id="L156">        int pos = segment.getCollectionIndex();</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">        while (array.size() &lt; pos + 1) {</span>
<span class="fc" id="L158">            array.add(null);</span>
        }
<span class="fc bfc" id="L160" title="All 2 branches covered.">        if (array.get(pos) == null) {</span>
<span class="fc" id="L161">            array.set(pos, new Struct(schema));</span>
        }
<span class="fc" id="L163">        writeSegment(path, index + 1, array.get(pos), schema, field);</span>
<span class="fc" id="L164">        return array;</span>
    }

    /**
     * Dirty hack. In current Kafka Connect implementation, &lt;code&gt;Struct#put()&lt;/code&gt; throws an Exception
     * if non-optional child doesn't have a value.
     * @param schema
     * @return modified schema
     */
    private Schema enforceDefaultOrOptional(Schema schema) {
<span class="pc bpc" id="L174" title="1 of 4 branches missed.">        if (!schema.isOptional() &amp;&amp; schema.defaultValue() == null) {</span>
<span class="fc" id="L175">            LOG.warn(&quot;Enforcing schema to be optional since there is no default value. &quot;</span>
                + &quot;It is recommended to either 1) define a default value or 2) set it optional in the Kafka Connect schema.&quot;);
            try {
<span class="fc" id="L178">                java.lang.reflect.Field optionalField = ConnectSchema.class.getDeclaredField(&quot;optional&quot;);</span>
<span class="fc" id="L179">                optionalField.setAccessible(true);</span>
<span class="fc" id="L180">                optionalField.setBoolean(schema, true);</span>
<span class="nc" id="L181">            } catch (Exception e) {</span>
<span class="nc" id="L182">                LOG.warn(&quot;&quot;, e);</span>
<span class="fc" id="L183">            }</span>
        }
<span class="pc bpc" id="L185" title="1 of 4 branches missed.">        switch (schema.type()) {</span>
            case ARRAY:
<span class="fc" id="L187">                enforceDefaultOrOptional(schema.valueSchema());</span>
<span class="fc" id="L188">                break;</span>
            case STRUCT:
<span class="fc" id="L190">                schema.fields().forEach(f -&gt; enforceDefaultOrOptional(f.schema()));</span>
<span class="fc" id="L191">                break;</span>
            case MAP:
<span class="nc" id="L193">                enforceDefaultOrOptional(schema.keySchema());</span>
<span class="nc" id="L194">                enforceDefaultOrOptional(schema.valueSchema());</span>
<span class="nc" id="L195">                break;</span>
            default:
        }
<span class="fc" id="L198">        return schema;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>